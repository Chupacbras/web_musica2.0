{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// This function gets unwrapped into global scope, which is why we don't invert\n// if-blocks. Also, you cannot use `return`.\nfunction default_1() {\n  // Wrapped in an IIFE to avoid polluting the global scope\n  ;\n  (function () {\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n    // AMP / No-JS mode does not inject these helpers:\n    '$RefreshHelpers$' in self) {\n      // @ts-ignore __webpack_module__ is global\n      var currentExports = __webpack_module__.exports;\n      // @ts-ignore __webpack_module__ is global\n      var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n      // This cannot happen in MainTemplate because the exports mismatch between\n      // templating and execution.\n      self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n      // A module can be accepted automatically based on its exports, e.g. when\n      // it is a Refresh Boundary.\n      if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n        // Save the previous exports signature on update so we can compare the boundary\n        // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n        __webpack_module__.hot.dispose(function (data) {\n          data.prevSignature = self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n        });\n        // Unconditionally accept an update to this module, we'll check if it's\n        // still a Refresh Boundary later.\n        // @ts-ignore importMeta is replaced in the loader\n        global.importMeta.webpackHot.accept();\n        // This field is set when the previous version of this module was a\n        // Refresh Boundary, letting us know we need to check for invalidation or\n        // enqueue an update.\n        if (prevSignature !== null) {\n          // A boundary can become ineligible if its exports are incompatible\n          // with the previous exports.\n          //\n          // For example, if you add/remove/change exports, we'll want to\n          // re-execute the importing modules, and force those components to\n          // re-render. Similarly, if you convert a class component to a\n          // function, we want to invalidate the boundary.\n          if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n            __webpack_module__.hot.invalidate();\n          } else {\n            self.$RefreshHelpers$.scheduleUpdate();\n          }\n        }\n      } else {\n        // Since we just executed the code for the module, it's possible that the\n        // new exports made it ineligible for being a boundary.\n        // We only care about the case when we were _previously_ a boundary,\n        // because we already accepted this update (accidental side effect).\n        var isNoLongerABoundary = prevSignature !== null;\n        if (isNoLongerABoundary) {\n          __webpack_module__.hot.invalidate();\n        }\n      }\n    }\n  })();\n}\nexports.default = default_1;","map":{"version":3,"names":["Object","defineProperty","exports","value","default_1","_a","_b","self","currentExports","__webpack_module__","prevSignature","hot","data","$RefreshHelpers$","registerExportsForReactRefresh","id","isReactRefreshBoundary","dispose","getRefreshBoundarySignature","global","importMeta","webpackHot","accept","shouldInvalidateReactRefreshBoundary","invalidate","scheduleUpdate","isNoLongerABoundary","default"],"sources":["/Users/albertformatger/Documents/GitHub/web_musica/node_modules/next/dist/compiled/@next/react-refresh-utils/dist/internal/ReactRefreshModule.runtime.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// This function gets unwrapped into global scope, which is why we don't invert\n// if-blocks. Also, you cannot use `return`.\nfunction default_1() {\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                global.importMeta.webpackHot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n}\nexports.default = default_1;\n//# sourceMappingURL=ReactRefreshModule.runtime.js.map"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7D;AACA;AACA,SAASC,SAASA,CAAA,EAAG;EACjB;EACA;EACA,CAAC,YAAY;IACT,IAAIC,EAAE,EAAEC,EAAE;IACV;IACA;IACA;IACA,IAAI,OAAOC,IAAI,KAAK,WAAW;IAC3B;IACA,kBAAkB,IAAIA,IAAI,EAAE;MAC5B;MACA,IAAIC,cAAc,GAAGC,kBAAkB,CAACP,OAAO;MAC/C;MACA,IAAIQ,aAAa,GAAG,CAACJ,EAAE,GAAG,CAACD,EAAE,GAAGI,kBAAkB,CAACE,GAAG,CAACC,IAAI,MAAM,IAAI,IAAIP,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACK,aAAa,MAAM,IAAI,IAAIJ,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,IAAI;MACzJ;MACA;MACAC,IAAI,CAACM,gBAAgB,CAACC,8BAA8B,CAACN,cAAc,EAAEC,kBAAkB,CAACM,EAAE,CAAC;MAC3F;MACA;MACA,IAAIR,IAAI,CAACM,gBAAgB,CAACG,sBAAsB,CAACR,cAAc,CAAC,EAAE;QAC9D;QACA;QACAC,kBAAkB,CAACE,GAAG,CAACM,OAAO,CAAC,UAAUL,IAAI,EAAE;UAC3CA,IAAI,CAACF,aAAa,GACdH,IAAI,CAACM,gBAAgB,CAACK,2BAA2B,CAACV,cAAc,CAAC;QACzE,CAAC,CAAC;QACF;QACA;QACA;QACAW,MAAM,CAACC,UAAU,CAACC,UAAU,CAACC,MAAM,CAAC,CAAC;QACrC;QACA;QACA;QACA,IAAIZ,aAAa,KAAK,IAAI,EAAE;UACxB;UACA;UACA;UACA;UACA;UACA;UACA;UACA,IAAIH,IAAI,CAACM,gBAAgB,CAACU,oCAAoC,CAACb,aAAa,EAAEH,IAAI,CAACM,gBAAgB,CAACK,2BAA2B,CAACV,cAAc,CAAC,CAAC,EAAE;YAC9IC,kBAAkB,CAACE,GAAG,CAACa,UAAU,CAAC,CAAC;UACvC,CAAC,MACI;YACDjB,IAAI,CAACM,gBAAgB,CAACY,cAAc,CAAC,CAAC;UAC1C;QACJ;MACJ,CAAC,MACI;QACD;QACA;QACA;QACA;QACA,IAAIC,mBAAmB,GAAGhB,aAAa,KAAK,IAAI;QAChD,IAAIgB,mBAAmB,EAAE;UACrBjB,kBAAkB,CAACE,GAAG,CAACa,UAAU,CAAC,CAAC;QACvC;MACJ;IACJ;EACJ,CAAC,EAAE,CAAC;AACR;AACAtB,OAAO,CAACyB,OAAO,GAAGvB,SAAS"},"metadata":{},"sourceType":"script","externalDependencies":[]}