{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"NextTypesPlugin\", {\n  enumerable: true,\n  get: function () {\n    return NextTypesPlugin;\n  }\n});\nconst _promises = /*#__PURE__*/_interop_require_default(require(\"fs/promises\"));\nconst _webpack = require(\"next/dist/compiled/webpack/webpack\");\nconst _pathtoregexp = require(\"next/dist/compiled/path-to-regexp\");\nconst _path = /*#__PURE__*/_interop_require_default(require(\"path\"));\nconst _constants = require(\"../../../../lib/constants\");\nconst _denormalizepagepath = require(\"../../../../shared/lib/page-path/denormalize-page-path\");\nconst _ensureleadingslash = require(\"../../../../shared/lib/page-path/ensure-leading-slash\");\nconst _normalizepathsep = require(\"../../../../shared/lib/page-path/normalize-path-sep\");\nconst _http = require(\"../../../../server/web/http\");\nconst _utils = require(\"../../../../shared/lib/router/utils\");\nconst _apppaths = require(\"../../../../shared/lib/router/utils/app-paths\");\nconst _entries = require(\"../../../entries\");\nconst _shared = require(\"./shared\");\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nconst PLUGIN_NAME = \"NextTypesPlugin\";\nfunction createTypeGuardFile(fullPath, relativePath, options) {\n  return `// File: ${fullPath}\nimport * as entry from '${relativePath}.js'\n${options.type === \"route\" ? `import type { NextRequest } from 'next/server.js'` : `import type { ResolvingMetadata } from 'next/dist/lib/metadata/types/metadata-interface.js'`}\n\ntype TEntry = typeof import('${relativePath}.js')\n\n// Check that the entry is a valid entry\ncheckFields<Diff<{\n  ${options.type === \"route\" ? _http.HTTP_METHODS.map(method => `${method}?: Function`).join(\"\\n  \") : \"default: Function\"}\n  config?: {}\n  generateStaticParams?: Function\n  revalidate?: RevalidateRange<TEntry> | false\n  dynamic?: 'auto' | 'force-dynamic' | 'error' | 'force-static'\n  dynamicParams?: boolean\n  fetchCache?: 'auto' | 'force-no-store' | 'only-no-store' | 'default-no-store' | 'default-cache' | 'only-cache' | 'force-cache'\n  preferredRegion?: 'auto' | 'global' | 'home' | string | string[]\n  runtime?: 'nodejs' | 'experimental-edge' | 'edge'\n  maxDuration?: number\n  ${options.type === \"route\" ? \"\" : `\n  metadata?: any\n  generateMetadata?: Function\n  `}\n}, TEntry, ''>>()\n\n${options.type === \"route\" ? _http.HTTP_METHODS.map(method => `// Check the prop type of the entry function\nif ('${method}' in entry) {\n  checkFields<\n    Diff<\n      ParamCheck<Request | NextRequest>,\n      {\n        __tag__: '${method}'\n        __param_position__: 'first'\n        __param_type__: FirstArg<MaybeField<TEntry, '${method}'>>\n      },\n      '${method}'\n    >\n  >()\n  checkFields<\n    Diff<\n      ParamCheck<PageParams>,\n      {\n        __tag__: '${method}'\n        __param_position__: 'second'\n        __param_type__: SecondArg<MaybeField<TEntry, '${method}'>>\n      },\n      '${method}'\n    >\n  >()\n  ${\"\"}\n  checkFields<\n    Diff<\n      {\n        __tag__: '${method}',\n        __return_type__: Response | void | never | Promise<Response | void | never>\n      },\n      {\n        __tag__: '${method}',\n        __return_type__: ReturnType<MaybeField<TEntry, '${method}'>>\n      },\n      '${method}'\n    >\n  >()\n}\n`).join(\"\") : `// Check the prop type of the entry function\ncheckFields<Diff<${options.type === \"page\" ? \"PageProps\" : \"LayoutProps\"}, FirstArg<TEntry['default']>, 'default'>>()\n\n// Check the arguments and return type of the generateMetadata function\nif ('generateMetadata' in entry) {\n  checkFields<Diff<${options.type === \"page\" ? \"PageProps\" : \"LayoutProps\"}, FirstArg<MaybeField<TEntry, 'generateMetadata'>>, 'generateMetadata'>>()\n  checkFields<Diff<ResolvingMetadata, SecondArg<MaybeField<TEntry, 'generateMetadata'>>, 'generateMetadata'>>()\n}\n`}\n// Check the arguments and return type of the generateStaticParams function\nif ('generateStaticParams' in entry) {\n  checkFields<Diff<{ params: PageParams }, FirstArg<MaybeField<TEntry, 'generateStaticParams'>>, 'generateStaticParams'>>()\n  checkFields<Diff<{ __tag__: 'generateStaticParams', __return_type__: any[] | Promise<any[]> }, { __tag__: 'generateStaticParams', __return_type__: ReturnType<MaybeField<TEntry, 'generateStaticParams'>> }>>()\n}\n\ntype PageParams = any\nexport interface PageProps {\n  params?: any\n  searchParams?: any\n}\nexport interface LayoutProps {\n  children?: React.ReactNode\n${options.slots ? options.slots.map(slot => `  ${slot}: React.ReactNode`).join(\"\\n\") : \"\"}\n  params?: any\n}\n\n// =============\n// Utility types\ntype RevalidateRange<T> = T extends { revalidate: any } ? NonNegative<T['revalidate']> : never\n\n// If T is unknown or any, it will be an empty {} type. Otherwise, it will be the same as Omit<T, keyof Base>.\ntype OmitWithTag<T, K extends keyof any, _M> = Omit<T, K>\ntype Diff<Base, T extends Base, Message extends string = ''> = 0 extends (1 & T) ? {} : OmitWithTag<T, keyof Base, Message>\n\ntype FirstArg<T extends Function> = T extends (...args: [infer T, any]) => any ? unknown extends T ? any : T : never\ntype SecondArg<T extends Function> = T extends (...args: [any, infer T]) => any ? unknown extends T ? any : T : never\ntype MaybeField<T, K extends string> = T extends { [k in K]: infer G } ? G extends Function ? G : never : never\n\n${options.type === \"route\" ? `type ParamCheck<T> = {\n  __tag__: string\n  __param_position__: string\n  __param_type__: T\n}` : \"\"}\n\nfunction checkFields<_ extends { [k in keyof any]: never }>() {}\n\n// https://github.com/sindresorhus/type-fest\ntype Numeric = number | bigint\ntype Zero = 0 | 0n\ntype Negative<T extends Numeric> = T extends Zero ? never : \\`\\${T}\\` extends \\`-\\${string}\\` ? T : never\ntype NonNegative<T extends Numeric> = T extends Zero ? T : Negative<T> extends never ? T : '__invalid_negative_number__'\n`;\n}\nasync function collectNamedSlots(layoutPath) {\n  const layoutDir = _path.default.dirname(layoutPath);\n  const items = await _promises.default.readdir(layoutDir, {\n    withFileTypes: true\n  });\n  const slots = [];\n  for (const item of items) {\n    if (item.isDirectory() && item.name.startsWith(\"@\")) {\n      slots.push(item.name.slice(1));\n    }\n  }\n  return slots;\n}\n// By exposing the static route types separately as string literals,\n// editors can provide autocompletion for them. However it's currently not\n// possible to provide the same experience for dynamic routes.\nconst routeTypes = {\n  edge: {\n    static: \"\",\n    dynamic: \"\"\n  },\n  node: {\n    static: \"\",\n    dynamic: \"\"\n  },\n  extra: {\n    static: \"\",\n    dynamic: \"\"\n  }\n};\nfunction formatRouteToRouteType(route) {\n  const isDynamic = (0, _utils.isDynamicRoute)(route);\n  if (isDynamic) {\n    route = route.split(\"/\").map(part => {\n      if (part.startsWith(\"[\") && part.endsWith(\"]\")) {\n        if (part.startsWith(\"[...\")) {\n          // /[...slug]\n          return `\\${CatchAllSlug<T>}`;\n        } else if (part.startsWith(\"[[...\") && part.endsWith(\"]]\")) {\n          // /[[...slug]]\n          return `\\${OptionalCatchAllSlug<T>}`;\n        }\n        // /[slug]\n        return `\\${SafeSlug<T>}`;\n      }\n      return part;\n    }).join(\"/\");\n  }\n  return {\n    isDynamic,\n    routeType: `\\n    | \\`${route}\\``\n  };\n}\n// Whether redirects and rewrites have been converted into routeTypes or not.\nlet redirectsRewritesTypesProcessed = false;\n// Convert redirects and rewrites into routeTypes.\nfunction addRedirectsRewritesRouteTypes(rewrites, redirects) {\n  function addExtraRoute(source) {\n    let tokens;\n    try {\n      tokens = (0, _pathtoregexp.parse)(source);\n    } catch {\n      // Ignore invalid routes - they will be handled by other checks.\n    }\n    if (Array.isArray(tokens)) {\n      const possibleNormalizedRoutes = [\"\"];\n      let slugCnt = 1;\n      function append(suffix) {\n        for (let i = 0; i < possibleNormalizedRoutes.length; i++) {\n          possibleNormalizedRoutes[i] += suffix;\n        }\n      }\n      function fork(suffix) {\n        const currentLength = possibleNormalizedRoutes.length;\n        for (let i = 0; i < currentLength; i++) {\n          possibleNormalizedRoutes.push(possibleNormalizedRoutes[i] + suffix);\n        }\n      }\n      for (const token of tokens) {\n        if (typeof token === \"object\") {\n          // Make sure the slug is always named.\n          const slug = token.name || (slugCnt++ === 1 ? \"slug\" : `slug${slugCnt}`);\n          if (token.modifier === \"*\") {\n            append(`${token.prefix}[[...${slug}]]`);\n          } else if (token.modifier === \"+\") {\n            append(`${token.prefix}[...${slug}]`);\n          } else if (token.modifier === \"\") {\n            if (token.pattern === \"[^\\\\/#\\\\?]+?\") {\n              // A safe slug\n              append(`${token.prefix}[${slug}]`);\n            } else if (token.pattern === \".*\") {\n              // An optional catch-all slug\n              append(`${token.prefix}[[...${slug}]]`);\n            } else if (token.pattern === \".+\") {\n              // A catch-all slug\n              append(`${token.prefix}[...${slug}]`);\n            } else {\n              // Other regex patterns are not supported. Skip this route.\n              return;\n            }\n          } else if (token.modifier === \"?\") {\n            if (/^[a-zA-Z0-9_/]*$/.test(token.pattern)) {\n              // An optional slug with plain text only, fork the route.\n              append(token.prefix);\n              fork(token.pattern);\n            } else {\n              // Optional modifier `?` and regex patterns are not supported.\n              return;\n            }\n          }\n        } else if (typeof token === \"string\") {\n          append(token);\n        }\n      }\n      for (const normalizedRoute of possibleNormalizedRoutes) {\n        const {\n          isDynamic,\n          routeType\n        } = formatRouteToRouteType(normalizedRoute);\n        routeTypes.extra[isDynamic ? \"dynamic\" : \"static\"] += routeType;\n      }\n    }\n  }\n  if (rewrites) {\n    for (const rewrite of rewrites.beforeFiles) {\n      addExtraRoute(rewrite.source);\n    }\n    for (const rewrite of rewrites.afterFiles) {\n      addExtraRoute(rewrite.source);\n    }\n    for (const rewrite of rewrites.fallback) {\n      addExtraRoute(rewrite.source);\n    }\n  }\n  if (redirects) {\n    for (const redirect of redirects) {\n      // Skip internal redirects\n      // https://github.com/vercel/next.js/blob/8ff3d7ff57836c24088474175d595b4d50b3f857/packages/next/src/lib/load-custom-routes.ts#L704-L710\n      if (!(\"internal\" in redirect)) {\n        addExtraRoute(redirect.source);\n      }\n    }\n  }\n}\nfunction createRouteDefinitions() {\n  let staticRouteTypes = \"\";\n  let dynamicRouteTypes = \"\";\n  for (const type of [\"edge\", \"node\", \"extra\"]) {\n    staticRouteTypes += routeTypes[type].static;\n    dynamicRouteTypes += routeTypes[type].dynamic;\n  }\n  // If both StaticRoutes and DynamicRoutes are empty, fallback to type 'string'.\n  const routeTypesFallback = !staticRouteTypes && !dynamicRouteTypes ? \"string\" : \"\";\n  return `// Type definitions for Next.js routes\n\n/**\n * Internal types used by the Next.js router and Link component.\n * These types are not meant to be used directly.\n * @internal\n */\ndeclare namespace __next_route_internal_types__ {\n  type SearchOrHash = \\`?\\${string}\\` | \\`#\\${string}\\`\n  type WithProtocol = \\`\\${string}:\\${string}\\`\n\n  type Suffix = '' | SearchOrHash\n\n  type SafeSlug<S extends string> = S extends \\`\\${string}/\\${string}\\`\n    ? never\n    : S extends \\`\\${string}\\${SearchOrHash}\\`\n    ? never\n    : S extends ''\n    ? never\n    : S\n\n  type CatchAllSlug<S extends string> = S extends \\`\\${string}\\${SearchOrHash}\\`\n    ? never\n    : S extends ''\n    ? never\n    : S\n\n  type OptionalCatchAllSlug<S extends string> =\n    S extends \\`\\${string}\\${SearchOrHash}\\` ? never : S\n\n  type StaticRoutes = ${staticRouteTypes || \"never\"}\n  type DynamicRoutes<T extends string = string> = ${dynamicRouteTypes || \"never\"}\n\n  type RouteImpl<T> = ${routeTypesFallback || `\n    ${// This keeps autocompletion working for static routes.\n  \"| StaticRoutes\"}\n    | SearchOrHash\n    | WithProtocol\n    | \\`\\${StaticRoutes}\\${SearchOrHash}\\`\n    | (T extends \\`\\${DynamicRoutes<infer _>}\\${Suffix}\\` ? T : never)\n    `}\n}\n\ndeclare module 'next' {\n  export { default } from 'next/types/index.js'\n  export * from 'next/types/index.js'\n\n  export type Route<T extends string = string> =\n    __next_route_internal_types__.RouteImpl<T>\n}\n\ndeclare module 'next/link' {\n  import type { LinkProps as OriginalLinkProps } from 'next/dist/client/link.js'\n  import type { AnchorHTMLAttributes, DetailedHTMLProps } from 'react'\n  import type { UrlObject } from 'url'\n\n  type LinkRestProps = Omit<\n    Omit<\n      DetailedHTMLProps<\n        AnchorHTMLAttributes<HTMLAnchorElement>,\n        HTMLAnchorElement\n      >,\n      keyof OriginalLinkProps\n    > &\n      OriginalLinkProps,\n    'href'\n  >\n\n  export type LinkProps<RouteInferType> = LinkRestProps & {\n    /**\n     * The path or URL to navigate to. This is the only required prop. It can also be an object.\n     * @see https://nextjs.org/docs/api-reference/next/link\n     */\n    href: __next_route_internal_types__.RouteImpl<RouteInferType> | UrlObject\n  }\n\n  export default function Link<RouteType>(props: LinkProps<RouteType>): JSX.Element\n}\n\ndeclare module 'next/navigation' {\n  export * from 'next/dist/client/components/navigation.js'\n\n  import type { NavigateOptions, AppRouterInstance as OriginalAppRouterInstance } from 'next/dist/shared/lib/app-router-context.shared-runtime.js'\n  interface AppRouterInstance extends OriginalAppRouterInstance {\n    /**\n     * Navigate to the provided href.\n     * Pushes a new history entry.\n     */\n    push<RouteType>(href: __next_route_internal_types__.RouteImpl<RouteType>, options?: NavigateOptions): void\n    /**\n     * Navigate to the provided href.\n     * Replaces the current history entry.\n     */\n    replace<RouteType>(href: __next_route_internal_types__.RouteImpl<RouteType>, options?: NavigateOptions): void\n    /**\n     * Prefetch the provided href.\n     */\n    prefetch<RouteType>(href: __next_route_internal_types__.RouteImpl<RouteType>): void\n  }\n\n  export declare function useRouter(): AppRouterInstance;\n}\n`;\n}\nconst appTypesBasePath = _path.default.join(\"types\", \"app\");\nclass NextTypesPlugin {\n  constructor(options) {\n    this.dir = options.dir;\n    this.distDir = options.distDir;\n    this.appDir = options.appDir;\n    this.dev = options.dev;\n    this.isEdgeServer = options.isEdgeServer;\n    this.pageExtensions = options.pageExtensions;\n    this.pagesDir = _path.default.join(this.appDir, \"..\", \"pages\");\n    this.typedRoutes = options.typedRoutes;\n    this.distDirAbsolutePath = _path.default.join(this.dir, this.distDir);\n    if (this.typedRoutes && !redirectsRewritesTypesProcessed) {\n      redirectsRewritesTypesProcessed = true;\n      addRedirectsRewritesRouteTypes(options.originalRewrites, options.originalRedirects);\n    }\n  }\n  getRelativePathFromAppTypesDir(moduleRelativePathToAppDir) {\n    const moduleAbsolutePath = _path.default.join(this.appDir, moduleRelativePathToAppDir);\n    const moduleInAppTypesAbsolutePath = _path.default.join(this.distDirAbsolutePath, appTypesBasePath, moduleRelativePathToAppDir);\n    return _path.default.relative(moduleInAppTypesAbsolutePath + \"/..\", moduleAbsolutePath);\n  }\n  collectPage(filePath) {\n    if (!this.typedRoutes) return;\n    const isApp = filePath.startsWith(this.appDir + _path.default.sep);\n    const isPages = !isApp && filePath.startsWith(this.pagesDir + _path.default.sep);\n    if (!isApp && !isPages) {\n      return;\n    }\n    // Filter out non-page and non-route files in app dir\n    if (isApp && !/[/\\\\](?:page|route)\\.[^.]+$/.test(filePath)) {\n      return;\n    }\n    // Filter out non-page files in pages dir\n    if (isPages && /[/\\\\](?:_app|_document|_error|404|500)\\.[^.]+$/.test(filePath)) {\n      return;\n    }\n    let route = (isApp ? _apppaths.normalizeAppPath : _denormalizepagepath.denormalizePagePath)((0, _ensureleadingslash.ensureLeadingSlash)((0, _entries.getPageFromPath)(_path.default.relative(isApp ? this.appDir : this.pagesDir, filePath), this.pageExtensions)));\n    const {\n      isDynamic,\n      routeType\n    } = formatRouteToRouteType(route);\n    routeTypes[this.isEdgeServer ? \"edge\" : \"node\"][isDynamic ? \"dynamic\" : \"static\"] += routeType;\n  }\n  apply(compiler) {\n    // From asset root to dist root\n    const assetDirRelative = this.dev ? \"..\" : this.isEdgeServer ? \"..\" : \"../..\";\n    const handleModule = async (mod, assets) => {\n      if (!mod.resource) return;\n      if (!/\\.(js|jsx|ts|tsx|mjs)$/.test(mod.resource)) return;\n      if (!mod.resource.startsWith(this.appDir + _path.default.sep)) {\n        if (!this.dev) {\n          if (mod.resource.startsWith(this.pagesDir + _path.default.sep)) {\n            this.collectPage(mod.resource);\n          }\n        }\n        return;\n      }\n      if (mod.layer !== _constants.WEBPACK_LAYERS.reactServerComponents && mod.layer !== _constants.WEBPACK_LAYERS.appRouteHandler) return;\n      const IS_LAYOUT = /[/\\\\]layout\\.[^./\\\\]+$/.test(mod.resource);\n      const IS_PAGE = !IS_LAYOUT && /[/\\\\]page\\.[^.]+$/.test(mod.resource);\n      const IS_ROUTE = !IS_PAGE && /[/\\\\]route\\.[^.]+$/.test(mod.resource);\n      const relativePathToApp = _path.default.relative(this.appDir, mod.resource);\n      if (!this.dev) {\n        if (IS_PAGE || IS_ROUTE) {\n          this.collectPage(mod.resource);\n        }\n      }\n      const typePath = _path.default.join(appTypesBasePath, relativePathToApp.replace(/\\.(js|jsx|ts|tsx|mjs)$/, \".ts\"));\n      const relativeImportPath = (0, _normalizepathsep.normalizePathSep)(_path.default.join(this.getRelativePathFromAppTypesDir(relativePathToApp)).replace(/\\.(js|jsx|ts|tsx|mjs)$/, \"\"));\n      const assetPath = _path.default.join(assetDirRelative, typePath);\n      if (IS_LAYOUT) {\n        const slots = await collectNamedSlots(mod.resource);\n        assets[assetPath] = new _webpack.sources.RawSource(createTypeGuardFile(mod.resource, relativeImportPath, {\n          type: \"layout\",\n          slots\n        }));\n      } else if (IS_PAGE) {\n        assets[assetPath] = new _webpack.sources.RawSource(createTypeGuardFile(mod.resource, relativeImportPath, {\n          type: \"page\"\n        }));\n      } else if (IS_ROUTE) {\n        assets[assetPath] = new _webpack.sources.RawSource(createTypeGuardFile(mod.resource, relativeImportPath, {\n          type: \"route\"\n        }));\n      }\n    };\n    compiler.hooks.compilation.tap(PLUGIN_NAME, compilation => {\n      compilation.hooks.processAssets.tapAsync({\n        name: PLUGIN_NAME,\n        stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH\n      }, async (assets, callback) => {\n        const promises = [];\n        // Clear routes\n        if (this.isEdgeServer) {\n          routeTypes.edge.dynamic = \"\";\n          routeTypes.edge.static = \"\";\n        } else {\n          routeTypes.node.dynamic = \"\";\n          routeTypes.node.static = \"\";\n        }\n        compilation.chunkGroups.forEach(chunkGroup => {\n          chunkGroup.chunks.forEach(chunk => {\n            if (!chunk.name) return;\n            // Here we only track page and route chunks.\n            if (!chunk.name.startsWith(\"pages/\") && !(chunk.name.startsWith(\"app/\") && (chunk.name.endsWith(\"/page\") || chunk.name.endsWith(\"/route\")))) {\n              return;\n            }\n            const chunkModules = compilation.chunkGraph.getChunkModulesIterable(chunk);\n            for (const mod of chunkModules) {\n              promises.push(handleModule(mod, assets));\n              // If this is a concatenation, register each child to the parent ID.\n              const anyModule = mod;\n              if (anyModule.modules) {\n                anyModule.modules.forEach(concatenatedMod => {\n                  promises.push(handleModule(concatenatedMod, assets));\n                });\n              }\n            }\n          });\n        });\n        await Promise.all(promises);\n        // Support `\"moduleResolution\": \"Node16\" | \"NodeNext\"` with `\"type\": \"module\"`\n        const packageJsonAssetPath = _path.default.join(assetDirRelative, \"types/package.json\");\n        assets[packageJsonAssetPath] = new _webpack.sources.RawSource('{\"type\": \"module\"}');\n        if (this.typedRoutes) {\n          if (this.dev && !this.isEdgeServer) {\n            _shared.devPageFiles.forEach(file => {\n              this.collectPage(file);\n            });\n          }\n          const linkAssetPath = _path.default.join(assetDirRelative, \"types/link.d.ts\");\n          assets[linkAssetPath] = new _webpack.sources.RawSource(createRouteDefinitions());\n        }\n        callback();\n      });\n    });\n  }\n}","map":{"version":3,"names":["NextTypesPlugin","PLUGIN_NAME","createTypeGuardFile","fullPath","relativePath","options","type","_http","HTTP_METHODS","map","method","join","slots","slot","collectNamedSlots","layoutPath","layoutDir","_path","default","dirname","items","_promises","readdir","withFileTypes","item","isDirectory","name","startsWith","push","slice","routeTypes","edge","static","dynamic","node","extra","formatRouteToRouteType","route","isDynamic","_utils","isDynamicRoute","split","part","endsWith","routeType","redirectsRewritesTypesProcessed","addRedirectsRewritesRouteTypes","rewrites","redirects","addExtraRoute","source","tokens","_pathtoregexp","parse","Array","isArray","possibleNormalizedRoutes","slugCnt","append","suffix","i","length","fork","currentLength","token","slug","modifier","prefix","pattern","test","normalizedRoute","rewrite","beforeFiles","afterFiles","fallback","redirect","createRouteDefinitions","staticRouteTypes","dynamicRouteTypes","routeTypesFallback","appTypesBasePath","constructor","dir","distDir","appDir","dev","isEdgeServer","pageExtensions","pagesDir","typedRoutes","distDirAbsolutePath","originalRewrites","originalRedirects","getRelativePathFromAppTypesDir","moduleRelativePathToAppDir","moduleAbsolutePath","moduleInAppTypesAbsolutePath","relative","collectPage","filePath","isApp","sep","isPages","_apppaths","normalizeAppPath","_denormalizepagepath","denormalizePagePath","_ensureleadingslash","ensureLeadingSlash","_entries","getPageFromPath","apply","compiler","assetDirRelative","handleModule","mod","assets","resource","layer","_constants","WEBPACK_LAYERS","reactServerComponents","appRouteHandler","IS_LAYOUT","IS_PAGE","IS_ROUTE","relativePathToApp","typePath","replace","relativeImportPath","_normalizepathsep","normalizePathSep","assetPath","_webpack","sources","RawSource","hooks","compilation","tap","processAssets","tapAsync","stage","webpack","Compilation","PROCESS_ASSETS_STAGE_OPTIMIZE_HASH","callback","promises","chunkGroups","forEach","chunkGroup","chunks","chunk","chunkModules","chunkGraph","getChunkModulesIterable","anyModule","modules","concatenatedMod","Promise","all","packageJsonAssetPath","_shared","devPageFiles","file","linkAssetPath"],"sources":["../../../../../src/build/webpack/plugins/next-types-plugin/index.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}