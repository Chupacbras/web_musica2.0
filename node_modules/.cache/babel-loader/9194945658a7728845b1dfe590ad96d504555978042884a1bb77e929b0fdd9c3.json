{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  isAbortError: null,\n  pipeReadable: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  isAbortError: function () {\n    return isAbortError;\n  },\n  pipeReadable: function () {\n    return pipeReadable;\n  }\n});\nfunction isAbortError(e) {\n  return (e == null ? void 0 : e.name) === \"AbortError\";\n}\nasync function pipeReadable(readable, writable) {\n  const reader = readable.getReader();\n  let readerDone = false;\n  let writableClosed = false;\n  // It's not enough just to check for `writable.destroyed`, because the client\n  // may disconnect while we're waiting for a read. We need to immediately\n  // cancel the readable, and that requires an out-of-band listener.\n  function onClose() {\n    writableClosed = true;\n    writable.off(\"close\", onClose);\n    // If the reader is not yet done, we need to cancel it so that the stream\n    // source's resources can be cleaned up. If a read is in-progress, this\n    // will also ensure the read promise rejects and frees our resources.\n    if (!readerDone) {\n      readerDone = true;\n      reader.cancel().catch(() => {});\n    }\n  }\n  writable.on(\"close\", onClose);\n  try {\n    while (true) {\n      const {\n        done,\n        value\n      } = await reader.read();\n      readerDone = done;\n      if (done || writableClosed) {\n        break;\n      }\n      if (value) {\n        writable.write(value);\n        writable.flush == null ? void 0 : writable.flush.call(writable);\n      }\n    }\n  } catch (e) {\n    // If the client disconnects, we don't want to emit an unhandled error.\n    if (!isAbortError(e)) {\n      throw e;\n    }\n  } finally {\n    writable.off(\"close\", onClose);\n    // If we broke out of the loop because of a client disconnect, and the\n    // close event hasn't yet fired, we can early cancel.\n    if (!readerDone) {\n      reader.cancel().catch(() => {});\n    }\n    // If the client hasn't disconnected yet, end the writable so that the\n    // response sends the final bytes.\n    if (!writableClosed) {\n      writable.end();\n    }\n  }\n}","map":{"version":3,"names":["isAbortError","pipeReadable","e","name","readable","writable","reader","getReader","readerDone","writableClosed","onClose","off","cancel","catch","on","done","value","read","write","flush","call","end"],"sources":["../../src/server/pipe-readable.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;;;EAAgBA,YAAY,WAAAA,CAAA;WAAZA,YAAA;;EAwCMC,YAAY,WAAAA,CAAA;WAAZA,YAAA;;;AAxCf,SAASD,aAAaE,CAAM;EACjC,OAAO,CAAAA,CAAA,oBAAAA,CAAA,CAAGC,IAAI,MAAK;AACrB;AAsCO,eAAeF,aACpBG,QAAoC,EACpCC,QAAgC;EAEhC,MAAMC,MAAA,GAASF,QAAA,CAASG,SAAS;EACjC,IAAIC,UAAA,GAAa;EACjB,IAAIC,cAAA,GAAiB;EAErB;EACA;EACA;EACA,SAASC,QAAA;IACPD,cAAA,GAAiB;IACjBJ,QAAA,CAASM,GAAG,CAAC,SAASD,OAAA;IAEtB;IACA;IACA;IACA,IAAI,CAACF,UAAA,EAAY;MACfA,UAAA,GAAa;MACbF,MAAA,CAAOM,MAAM,GAAGC,KAAK,CAAC,OAAO;IAC/B;EACF;EACAR,QAAA,CAASS,EAAE,CAAC,SAASJ,OAAA;EAErB,IAAI;IACF,OAAO,MAAM;MACX,MAAM;QAAEK,IAAI;QAAEC;MAAK,CAAE,GAAG,MAAMV,MAAA,CAAOW,IAAI;MACzCT,UAAA,GAAaO,IAAA;MAEb,IAAIA,IAAA,IAAQN,cAAA,EAAgB;QAC1B;MACF;MAEA,IAAIO,KAAA,EAAO;QACTX,QAAA,CAASa,KAAK,CAACF,KAAA;QACfX,QAAA,CAASc,KAAK,oBAAdd,QAAA,CAASc,KAAK,CAAAC,IAAA,CAAdf,QAAA;MACF;IACF;EACF,EAAE,OAAOH,CAAA,EAAG;IACV;IACA,IAAI,CAACF,YAAA,CAAaE,CAAA,GAAI;MACpB,MAAMA,CAAA;IACR;EACF,UAAU;IACRG,QAAA,CAASM,GAAG,CAAC,SAASD,OAAA;IAEtB;IACA;IACA,IAAI,CAACF,UAAA,EAAY;MACfF,MAAA,CAAOM,MAAM,GAAGC,KAAK,CAAC,OAAO;IAC/B;IAEA;IACA;IACA,IAAI,CAACJ,cAAA,EAAgB;MACnBJ,QAAA,CAASgB,GAAG;IACd;EACF;AACF"},"metadata":{},"sourceType":"script","externalDependencies":[]}