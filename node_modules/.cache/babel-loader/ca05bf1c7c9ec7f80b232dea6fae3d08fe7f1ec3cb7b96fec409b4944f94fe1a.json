{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  AppRouteRouteModule: null,\n  default: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  AppRouteRouteModule: function () {\n    return AppRouteRouteModule;\n  },\n  default: function () {\n    return _default;\n  }\n});\nconst _routemodule = require(\"../route-module\");\nconst _requestasyncstoragewrapper = require(\"../../../async-storage/request-async-storage-wrapper\");\nconst _staticgenerationasyncstoragewrapper = require(\"../../../async-storage/static-generation-async-storage-wrapper\");\nconst _responsehandlers = require(\"../helpers/response-handlers\");\nconst _http = require(\"../../../web/http\");\nconst _patchfetch = require(\"../../../lib/patch-fetch\");\nconst _tracer = require(\"../../../lib/trace/tracer\");\nconst _constants = require(\"../../../lib/trace/constants\");\nconst _getpathnamefromabsolutepath = require(\"./helpers/get-pathname-from-absolute-path\");\nconst _proxyrequest = require(\"./helpers/proxy-request\");\nconst _resolvehandlererror = require(\"./helpers/resolve-handler-error\");\nconst _log = /*#__PURE__*/_interop_require_wildcard(require(\"../../../../build/output/log\"));\nconst _autoimplementmethods = require(\"./helpers/auto-implement-methods\");\nconst _getnonstaticmethods = require(\"./helpers/get-non-static-methods\");\nconst _requestcookies = require(\"../../../web/spec-extension/adapters/request-cookies\");\nconst _routekind = require(\"../../route-kind\");\nconst _parsedurlquerytoparams = require(\"./helpers/parsed-url-query-to-params\");\nconst _hooksservercontext = /*#__PURE__*/_interop_require_wildcard(require(\"../../../../client/components/hooks-server-context\"));\nconst _headers = /*#__PURE__*/_interop_require_wildcard(require(\"../../../../client/components/headers\"));\nconst _staticgenerationbailout = require(\"../../../../client/components/static-generation-bailout\");\nconst _requestasyncstorageexternal = require(\"../../../../client/components/request-async-storage.external\");\nconst _staticgenerationasyncstorageexternal = require(\"../../../../client/components/static-generation-async-storage.external\");\nconst _actionasyncstorageexternal = require(\"../../../../client/components/action-async-storage.external\");\nconst _sharedmodules = /*#__PURE__*/_interop_require_wildcard(require(\"./shared-modules\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nclass AppRouteRouteModule extends _routemodule.RouteModule {\n  static #_ = this.sharedModules = _sharedmodules;\n  static is(route) {\n    return route.definition.kind === _routekind.RouteKind.APP_ROUTE;\n  }\n  constructor({\n    userland,\n    definition,\n    resolvedPagePath,\n    nextConfigOutput\n  }) {\n    super({\n      userland,\n      definition\n    });\n    /**\n    * A reference to the request async storage.\n    */\n    this.requestAsyncStorage = _requestasyncstorageexternal.requestAsyncStorage;\n    /**\n    * A reference to the static generation async storage.\n    */\n    this.staticGenerationAsyncStorage = _staticgenerationasyncstorageexternal.staticGenerationAsyncStorage;\n    /**\n    * An interface to call server hooks which interact with the underlying\n    * storage.\n    */\n    this.serverHooks = _hooksservercontext;\n    /**\n    * An interface to call header hooks which interact with the underlying\n    * request storage.\n    */\n    this.headerHooks = _headers;\n    /**\n    * An interface to call static generation bailout hooks which interact with\n    * the underlying static generation storage.\n    */\n    this.staticGenerationBailout = _staticgenerationbailout.staticGenerationBailout;\n    /**\n    * A reference to the mutation related async storage, such as mutations of\n    * cookies.\n    */\n    this.actionAsyncStorage = _actionasyncstorageexternal.actionAsyncStorage;\n    this.resolvedPagePath = resolvedPagePath;\n    this.nextConfigOutput = nextConfigOutput;\n    // Automatically implement some methods if they aren't implemented by the\n    // userland module.\n    this.methods = (0, _autoimplementmethods.autoImplementMethods)(userland);\n    // Get the non-static methods for this route.\n    this.nonStaticMethods = (0, _getnonstaticmethods.getNonStaticMethods)(userland);\n    // Get the dynamic property from the userland module.\n    this.dynamic = this.userland.dynamic;\n    if (this.nextConfigOutput === \"export\") {\n      if (!this.dynamic || this.dynamic === \"auto\") {\n        this.dynamic = \"error\";\n      } else if (this.dynamic === \"force-dynamic\") {\n        throw new Error(`export const dynamic = \"force-dynamic\" on page \"${definition.pathname}\" cannot be used with \"output: export\". See more info here: https://nextjs.org/docs/advanced-features/static-html-export`);\n      }\n    }\n    // We only warn in development after here, so return if we're not in\n    // development.\n    if (process.env.NODE_ENV === \"development\") {\n      // Print error in development if the exported handlers are in lowercase, only\n      // uppercase handlers are supported.\n      const lowercased = _http.HTTP_METHODS.map(method => method.toLowerCase());\n      for (const method of lowercased) {\n        if (method in this.userland) {\n          _log.error(`Detected lowercase method '${method}' in '${this.resolvedPagePath}'. Export the uppercase '${method.toUpperCase()}' method name to fix this error.`);\n        }\n      }\n      // Print error if the module exports a default handler, they must use named\n      // exports for each HTTP method.\n      if (\"default\" in this.userland) {\n        _log.error(`Detected default export in '${this.resolvedPagePath}'. Export a named export for each HTTP method instead.`);\n      }\n      // If there is no methods exported by this module, then return a not found\n      // response.\n      if (!_http.HTTP_METHODS.some(method => method in this.userland)) {\n        _log.error(`No HTTP methods exported in '${this.resolvedPagePath}'. Export a named export for each HTTP method.`);\n      }\n    }\n  }\n  /**\n  * Resolves the handler function for the given method.\n  *\n  * @param method the requested method\n  * @returns the handler function for the given method\n  */\n  resolve(method) {\n    // Ensure that the requested method is a valid method (to prevent RCE's).\n    if (!(0, _http.isHTTPMethod)(method)) return _responsehandlers.handleBadRequestResponse;\n    // Return the handler.\n    return this.methods[method];\n  }\n  /**\n  * Executes the route handler.\n  */\n  async execute(request, context) {\n    // Get the handler function for the given method.\n    const handler = this.resolve(request.method);\n    // Get the context for the request.\n    const requestContext = {\n      req: request\n    };\n    requestContext.renderOpts = {\n      previewProps: context.prerenderManifest.preview\n    };\n    // Get the context for the static generation.\n    const staticGenerationContext = {\n      urlPathname: request.nextUrl.pathname,\n      renderOpts:\n      // If the staticGenerationContext is not provided then we default to\n      // the default values.\n      context.staticGenerationContext ?? {\n        supportsDynamicHTML: false,\n        originalPathname: this.definition.pathname\n      }\n    };\n    // Add the fetchCache option to the renderOpts.\n    staticGenerationContext.renderOpts.fetchCache = this.userland.fetchCache;\n    // Run the handler with the request AsyncLocalStorage to inject the helper\n    // support. We set this to `unknown` because the type is not known until\n    // runtime when we do a instanceof check below.\n    const response = await this.actionAsyncStorage.run({\n      isAppRoute: true\n    }, () => _requestasyncstoragewrapper.RequestAsyncStorageWrapper.wrap(this.requestAsyncStorage, requestContext, () => _staticgenerationasyncstoragewrapper.StaticGenerationAsyncStorageWrapper.wrap(this.staticGenerationAsyncStorage, staticGenerationContext, staticGenerationStore => {\n      var _getTracer_getRootSpanAttributes;\n      // Check to see if we should bail out of static generation based on\n      // having non-static methods.\n      if (this.nonStaticMethods) {\n        this.staticGenerationBailout(`non-static methods used ${this.nonStaticMethods.join(\", \")}`);\n      }\n      // Update the static generation store based on the dynamic property.\n      switch (this.dynamic) {\n        case \"force-dynamic\":\n          // The dynamic property is set to force-dynamic, so we should\n          // force the page to be dynamic.\n          staticGenerationStore.forceDynamic = true;\n          this.staticGenerationBailout(`force-dynamic`, {\n            dynamic: this.dynamic\n          });\n          break;\n        case \"force-static\":\n          // The dynamic property is set to force-static, so we should\n          // force the page to be static.\n          staticGenerationStore.forceStatic = true;\n          break;\n        case \"error\":\n          // The dynamic property is set to error, so we should throw an\n          // error if the page is being statically generated.\n          staticGenerationStore.dynamicShouldError = true;\n          break;\n        default:\n          break;\n      }\n      // If the static generation store does not have a revalidate value\n      // set, then we should set it the revalidate value from the userland\n      // module or default to false.\n      staticGenerationStore.revalidate ??= this.userland.revalidate ?? false;\n      // Wrap the request so we can add additional functionality to cases\n      // that might change it's output or affect the rendering.\n      const wrappedRequest = (0, _proxyrequest.proxyRequest)(request, {\n        dynamic: this.dynamic\n      }, {\n        headerHooks: this.headerHooks,\n        serverHooks: this.serverHooks,\n        staticGenerationBailout: this.staticGenerationBailout\n      });\n      // TODO: propagate this pathname from route matcher\n      const route = (0, _getpathnamefromabsolutepath.getPathnameFromAbsolutePath)(this.resolvedPagePath);\n      (_getTracer_getRootSpanAttributes = (0, _tracer.getTracer)().getRootSpanAttributes()) == null ? void 0 : _getTracer_getRootSpanAttributes.set(\"next.route\", route);\n      return (0, _tracer.getTracer)().trace(_constants.AppRouteRouteHandlersSpan.runHandler, {\n        spanName: `executing api route (app) ${route}`,\n        attributes: {\n          \"next.route\": route\n        }\n      }, async () => {\n        var _staticGenerationStore_tags;\n        // Patch the global fetch.\n        (0, _patchfetch.patchFetch)({\n          serverHooks: this.serverHooks,\n          staticGenerationAsyncStorage: this.staticGenerationAsyncStorage\n        });\n        const res = await handler(wrappedRequest, {\n          params: context.params ? (0, _parsedurlquerytoparams.parsedUrlQueryToParams)(context.params) : undefined\n        });\n        if (!(res instanceof Response)) {\n          throw new Error(`No response is returned from route handler '${this.resolvedPagePath}'. Ensure you return a \\`Response\\` or a \\`NextResponse\\` in all branches of your handler.`);\n        }\n        context.staticGenerationContext.fetchMetrics = staticGenerationStore.fetchMetrics;\n        await Promise.all(staticGenerationStore.pendingRevalidates || []);\n        (0, _patchfetch.addImplicitTags)(staticGenerationStore);\n        context.staticGenerationContext.fetchTags = (_staticGenerationStore_tags = staticGenerationStore.tags) == null ? void 0 : _staticGenerationStore_tags.join(\",\");\n        // It's possible cookies were set in the handler, so we need\n        // to merge the modified cookies and the returned response\n        // here.\n        const requestStore = this.requestAsyncStorage.getStore();\n        if (requestStore && requestStore.mutableCookies) {\n          const headers = new Headers(res.headers);\n          if ((0, _requestcookies.appendMutableCookies)(headers, requestStore.mutableCookies)) {\n            return new Response(res.body, {\n              status: res.status,\n              statusText: res.statusText,\n              headers\n            });\n          }\n        }\n        return res;\n      });\n    })));\n    // If the handler did't return a valid response, then return the internal\n    // error response.\n    if (!(response instanceof Response)) {\n      // TODO: validate the correct handling behavior, maybe log something?\n      return (0, _responsehandlers.handleInternalServerErrorResponse)();\n    }\n    if (response.headers.has(\"x-middleware-rewrite\")) {\n      // TODO: move this error into the `NextResponse.rewrite()` function.\n      // TODO-APP: re-enable support below when we can proxy these type of requests\n      throw new Error(\"NextResponse.rewrite() was used in a app route handler, this is not currently supported. Please remove the invocation to continue.\");\n      // // This is a rewrite created via `NextResponse.rewrite()`. We need to send\n      // // the response up so it can be handled by the backing server.\n      // // If the server is running in minimal mode, we just want to forward the\n      // // response (including the rewrite headers) upstream so it can perform the\n      // // redirect for us, otherwise return with the special condition so this\n      // // server can perform a rewrite.\n      // if (!minimalMode) {\n      //   return { response, condition: 'rewrite' }\n      // }\n      // // Relativize the url so it's relative to the base url. This is so the\n      // // outgoing headers upstream can be relative.\n      // const rewritePath = response.headers.get('x-middleware-rewrite')!\n      // const initUrl = getRequestMeta(req, '__NEXT_INIT_URL')!\n      // const { pathname } = parseUrl(relativizeURL(rewritePath, initUrl))\n      // response.headers.set('x-middleware-rewrite', pathname)\n    }\n\n    if (response.headers.get(\"x-middleware-next\") === \"1\") {\n      // TODO: move this error into the `NextResponse.next()` function.\n      throw new Error(\"NextResponse.next() was used in a app route handler, this is not supported. See here for more info: https://nextjs.org/docs/messages/next-response-next-in-app-route-handler\");\n    }\n    return response;\n  }\n  async handle(request, context) {\n    try {\n      // Execute the route to get the response.\n      const response = await this.execute(request, context);\n      // The response was handled, return it.\n      return response;\n    } catch (err) {\n      // Try to resolve the error to a response, else throw it again.\n      const response = (0, _resolvehandlererror.resolveHandlerError)(err);\n      if (!response) throw err;\n      // The response was resolved, return it.\n      return response;\n    }\n  }\n}\nconst _default = AppRouteRouteModule;","map":{"version":3,"names":["AppRouteRouteModule","default","_default","_routemodule","RouteModule","sharedModules","_sharedmodules","is","route","definition","kind","_routekind","RouteKind","APP_ROUTE","constructor","userland","resolvedPagePath","nextConfigOutput","requestAsyncStorage","_requestasyncstorageexternal","staticGenerationAsyncStorage","_staticgenerationasyncstorageexternal","serverHooks","_hooksservercontext","headerHooks","_headers","staticGenerationBailout","_staticgenerationbailout","actionAsyncStorage","_actionasyncstorageexternal","methods","_autoimplementmethods","autoImplementMethods","nonStaticMethods","_getnonstaticmethods","getNonStaticMethods","dynamic","Error","pathname","process","env","NODE_ENV","lowercased","_http","HTTP_METHODS","map","method","toLowerCase","_log","error","toUpperCase","some","resolve","isHTTPMethod","_responsehandlers","handleBadRequestResponse","execute","request","context","handler","requestContext","req","renderOpts","previewProps","prerenderManifest","preview","staticGenerationContext","urlPathname","nextUrl","supportsDynamicHTML","originalPathname","fetchCache","response","run","isAppRoute","_requestasyncstoragewrapper","RequestAsyncStorageWrapper","wrap","_staticgenerationasyncstoragewrapper","StaticGenerationAsyncStorageWrapper","staticGenerationStore","_getTracer_getRootSpanAttributes","join","forceDynamic","forceStatic","dynamicShouldError","revalidate","wrappedRequest","_proxyrequest","proxyRequest","_getpathnamefromabsolutepath","getPathnameFromAbsolutePath","_tracer","getTracer","getRootSpanAttributes","set","trace","_constants","AppRouteRouteHandlersSpan","runHandler","spanName","attributes","_staticGenerationStore_tags","_patchfetch","patchFetch","res","params","_parsedurlquerytoparams","parsedUrlQueryToParams","undefined","Response","fetchMetrics","Promise","all","pendingRevalidates","addImplicitTags","fetchTags","tags","requestStore","getStore","mutableCookies","headers","Headers","_requestcookies","appendMutableCookies","body","status","statusText","handleInternalServerErrorResponse","has","get","handle","err","_resolvehandlererror","resolveHandlerError"],"sources":["../../../../../src/server/future/route-modules/app-route/module.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}