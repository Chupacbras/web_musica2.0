{"ast":null,"code":"/**\n * This webpack resolver is largely based on TypeScript's \"paths\" handling\n * The TypeScript license can be found here:\n * https://github.com/microsoft/TypeScript/blob/214df64e287804577afa1fea0184c18c40f7d1ca/LICENSE.txt\n */\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  hasZeroOrOneAsteriskCharacter: null,\n  pathIsRelative: null,\n  tryParsePattern: null,\n  findBestPatternMatch: null,\n  matchPatternOrExact: null,\n  isString: null,\n  matchedText: null,\n  patternText: null,\n  JsConfigPathsPlugin: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  hasZeroOrOneAsteriskCharacter: function () {\n    return hasZeroOrOneAsteriskCharacter;\n  },\n  pathIsRelative: function () {\n    return pathIsRelative;\n  },\n  tryParsePattern: function () {\n    return tryParsePattern;\n  },\n  findBestPatternMatch: function () {\n    return findBestPatternMatch;\n  },\n  matchPatternOrExact: function () {\n    return matchPatternOrExact;\n  },\n  isString: function () {\n    return isString;\n  },\n  matchedText: function () {\n    return matchedText;\n  },\n  patternText: function () {\n    return patternText;\n  },\n  JsConfigPathsPlugin: function () {\n    return JsConfigPathsPlugin;\n  }\n});\nconst _path = /*#__PURE__*/_interop_require_default(require(\"path\"));\nconst _debug = require(\"next/dist/compiled/debug\");\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nconst log = (0, _debug.debug)(\"next:jsconfig-paths-plugin\");\nconst asterisk = 0x2a;\nfunction hasZeroOrOneAsteriskCharacter(str) {\n  let seenAsterisk = false;\n  for (let i = 0; i < str.length; i++) {\n    if (str.charCodeAt(i) === asterisk) {\n      if (!seenAsterisk) {\n        seenAsterisk = true;\n      } else {\n        // have already seen asterisk\n        return false;\n      }\n    }\n  }\n  return true;\n}\nfunction pathIsRelative(testPath) {\n  return /^\\.\\.?($|[\\\\/])/.test(testPath);\n}\nfunction tryParsePattern(pattern) {\n  // This should be verified outside of here and a proper error thrown.\n  const indexOfStar = pattern.indexOf(\"*\");\n  return indexOfStar === -1 ? undefined : {\n    prefix: pattern.slice(0, indexOfStar),\n    suffix: pattern.slice(indexOfStar + 1)\n  };\n}\nfunction isPatternMatch({\n  prefix,\n  suffix\n}, candidate) {\n  return candidate.length >= prefix.length + suffix.length && candidate.startsWith(prefix) && candidate.endsWith(suffix);\n}\nfunction findBestPatternMatch(values, getPattern, candidate) {\n  let matchedValue;\n  // use length of prefix as betterness criteria\n  let longestMatchPrefixLength = -1;\n  for (const v of values) {\n    const pattern = getPattern(v);\n    if (isPatternMatch(pattern, candidate) && pattern.prefix.length > longestMatchPrefixLength) {\n      longestMatchPrefixLength = pattern.prefix.length;\n      matchedValue = v;\n    }\n  }\n  return matchedValue;\n}\nfunction matchPatternOrExact(patternStrings, candidate) {\n  const patterns = [];\n  for (const patternString of patternStrings) {\n    if (!hasZeroOrOneAsteriskCharacter(patternString)) continue;\n    const pattern = tryParsePattern(patternString);\n    if (pattern) {\n      patterns.push(pattern);\n    } else if (patternString === candidate) {\n      // pattern was matched as is - no need to search further\n      return patternString;\n    }\n  }\n  return findBestPatternMatch(patterns, _ => _, candidate);\n}\nfunction isString(text) {\n  return typeof text === \"string\";\n}\nfunction matchedText(pattern, candidate) {\n  return candidate.substring(pattern.prefix.length, candidate.length - pattern.suffix.length);\n}\nfunction patternText({\n  prefix,\n  suffix\n}) {\n  return `${prefix}*${suffix}`;\n}\n/**\n * Calls the iterator function for each entry of the array\n * until the first result or error is reached\n */\nfunction forEachBail(array, iterator, callback) {\n  if (array.length === 0) return callback();\n  let i = 0;\n  const next = () => {\n    let loop = undefined;\n    iterator(array[i++], (err, result) => {\n      if (err || result !== undefined || i >= array.length) {\n        return callback(err, result);\n      }\n      if (loop === false) while (next());\n      loop = true;\n    });\n    if (!loop) loop = false;\n    return loop;\n  };\n  while (next());\n}\nconst NODE_MODULES_REGEX = /node_modules/;\nclass JsConfigPathsPlugin {\n  constructor(paths, resolvedBaseUrl) {\n    this.paths = paths;\n    this.resolvedBaseUrl = resolvedBaseUrl;\n    this.jsConfigPlugin = true;\n    log(\"tsconfig.json or jsconfig.json paths: %O\", paths);\n    log(\"resolved baseUrl: %s\", resolvedBaseUrl);\n  }\n  apply(resolver) {\n    const target = resolver.ensureHook(\"resolve\");\n    resolver.getHook(\"described-resolve\").tapAsync(\"JsConfigPathsPlugin\", (request, resolveContext, callback) => {\n      const paths = this.paths;\n      const pathsKeys = Object.keys(paths);\n      // If no aliases are added bail out\n      if (pathsKeys.length === 0) {\n        log(\"paths are empty, bailing out\");\n        return callback();\n      }\n      const moduleName = request.request;\n      // Exclude node_modules from paths support (speeds up resolving)\n      if (request.path.match(NODE_MODULES_REGEX)) {\n        log(\"skipping request as it is inside node_modules %s\", moduleName);\n        return callback();\n      }\n      if (_path.default.posix.isAbsolute(moduleName) || process.platform === \"win32\" && _path.default.win32.isAbsolute(moduleName)) {\n        log(\"skipping request as it is an absolute path %s\", moduleName);\n        return callback();\n      }\n      if (pathIsRelative(moduleName)) {\n        log(\"skipping request as it is a relative path %s\", moduleName);\n        return callback();\n      }\n      // log('starting to resolve request %s', moduleName)\n      // If the module name does not match any of the patterns in `paths` we hand off resolving to webpack\n      const matchedPattern = matchPatternOrExact(pathsKeys, moduleName);\n      if (!matchedPattern) {\n        log(\"moduleName did not match any paths pattern %s\", moduleName);\n        return callback();\n      }\n      const matchedStar = isString(matchedPattern) ? undefined : matchedText(matchedPattern, moduleName);\n      const matchedPatternText = isString(matchedPattern) ? matchedPattern : patternText(matchedPattern);\n      let triedPaths = [];\n      forEachBail(paths[matchedPatternText], (subst, pathCallback) => {\n        const curPath = matchedStar ? subst.replace(\"*\", matchedStar) : subst;\n        // Ensure .d.ts is not matched\n        if (curPath.endsWith(\".d.ts\")) {\n          // try next path candidate\n          return pathCallback();\n        }\n        const candidate = _path.default.join(this.resolvedBaseUrl, curPath);\n        const obj = Object.assign({}, request, {\n          request: candidate\n        });\n        resolver.doResolve(target, obj, `Aliased with tsconfig.json or jsconfig.json ${matchedPatternText} to ${candidate}`, resolveContext, (resolverErr, resolverResult) => {\n          if (resolverErr || resolverResult === undefined) {\n            triedPaths.push(candidate);\n            // try next path candidate\n            return pathCallback();\n          }\n          return pathCallback(resolverErr, resolverResult);\n        });\n      }, callback);\n    });\n  }\n}","map":{"version":3,"names":["hasZeroOrOneAsteriskCharacter","pathIsRelative","tryParsePattern","findBestPatternMatch","matchPatternOrExact","isString","matchedText","patternText","JsConfigPathsPlugin","log","_debug","debug","asterisk","str","seenAsterisk","i","length","charCodeAt","testPath","test","pattern","indexOfStar","indexOf","undefined","prefix","slice","suffix","isPatternMatch","candidate","startsWith","endsWith","values","getPattern","matchedValue","longestMatchPrefixLength","v","patternStrings","patterns","patternString","push","_","text","substring","forEachBail","array","iterator","callback","next","loop","err","result","NODE_MODULES_REGEX","constructor","paths","resolvedBaseUrl","jsConfigPlugin","apply","resolver","target","ensureHook","getHook","tapAsync","request","resolveContext","pathsKeys","Object","keys","moduleName","path","match","_path","default","posix","isAbsolute","process","platform","win32","matchedPattern","matchedStar","matchedPatternText","triedPaths","subst","pathCallback","curPath","replace","join","obj","assign","doResolve","resolverErr","resolverResult"],"sources":["../../../../src/build/webpack/plugins/jsconfig-paths-plugin.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}