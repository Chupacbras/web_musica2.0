{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"createIpcServer\", {\n  enumerable: true,\n  get: function () {\n    return createIpcServer;\n  }\n});\nconst _render = require(\"../../render\");\nconst _crypto = /*#__PURE__*/_interop_require_default(require(\"crypto\"));\nconst _iserror = /*#__PURE__*/_interop_require_default(require(\"../../../lib/is-error\"));\nconst _requestutils = require(\"./request-utils\");\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nasync function createIpcServer(server) {\n  // Generate a random key in memory to validate messages from other processes.\n  // This is just a simple guard against other processes attempting to send\n  // traffic to the IPC server.\n  const ipcValidationKey = _crypto.default.randomBytes(32).toString(\"hex\");\n  const ipcServer = require(\"http\").createServer(async (req, res) => {\n    try {\n      const url = new URL(req.url || \"/\", \"http://n\");\n      const key = url.searchParams.get(\"key\");\n      if (key !== ipcValidationKey) {\n        return res.end();\n      }\n      const method = url.searchParams.get(\"method\");\n      const args = JSON.parse(url.searchParams.get(\"args\") || \"[]\");\n      if (!method || !Array.isArray(args)) {\n        return res.end();\n      }\n      if (typeof server[method] === \"function\") {\n        var _args_;\n        if (method === \"logErrorWithOriginalStack\" && ((_args_ = args[0]) == null ? void 0 : _args_.stack)) {\n          args[0] = (0, _requestutils.deserializeErr)(args[0]);\n        }\n        let result = await server[method](...args);\n        if (result && typeof result === \"object\" && result.stack) {\n          result = (0, _render.errorToJSON)(result);\n        }\n        res.end(JSON.stringify(result || \"\"));\n      }\n    } catch (err) {\n      if ((0, _iserror.default)(err) && err.code !== \"ENOENT\") {\n        console.error(err);\n      }\n      res.end(JSON.stringify({\n        err: {\n          name: err.name,\n          message: err.message,\n          stack: err.stack\n        }\n      }));\n    }\n  });\n  const ipcPort = await new Promise(resolveIpc => {\n    ipcServer.listen(0, server.hostname, () => {\n      const addr = ipcServer.address();\n      if (addr && typeof addr === \"object\") {\n        resolveIpc(addr.port);\n      }\n    });\n  });\n  return {\n    ipcPort,\n    ipcServer,\n    ipcValidationKey\n  };\n}","map":{"version":3,"names":["createIpcServer","server","ipcValidationKey","_crypto","default","randomBytes","toString","ipcServer","require","createServer","req","res","url","URL","key","searchParams","get","end","method","args","JSON","parse","Array","isArray","_args_","stack","_requestutils","deserializeErr","result","_render","errorToJSON","stringify","err","_iserror","code","console","error","name","message","ipcPort","Promise","resolveIpc","listen","hostname","addr","address","port"],"sources":["../../../../src/server/lib/server-ipc/index.ts"],"sourcesContent":[null],"mappings":";;;;;+BASsB;;;WAAAA,eAAA;;;wBARM;8DACT;+DACC;8BACW;;;;;;AAKxB,eAAeA,gBACpBC,MAAuC;EAMvC;EACA;EACA;EACA,MAAMC,gBAAA,GAAmBC,OAAA,CAAAC,OAAM,CAACC,WAAW,CAAC,IAAIC,QAAQ,CAAC;EAEzD,MAAMC,SAAA,GAAYC,OAAC,CAAQ,QAAkCC,YAAY,CACvE,OAAOC,GAAA,EAAKC,GAAA;IACV,IAAI;MACF,MAAMC,GAAA,GAAM,IAAIC,GAAA,CAAIH,GAAA,CAAIE,GAAG,IAAI,KAAK;MACpC,MAAME,GAAA,GAAMF,GAAA,CAAIG,YAAY,CAACC,GAAG,CAAC;MAEjC,IAAIF,GAAA,KAAQZ,gBAAA,EAAkB;QAC5B,OAAOS,GAAA,CAAIM,GAAG;MAChB;MAEA,MAAMC,MAAA,GAASN,GAAA,CAAIG,YAAY,CAACC,GAAG,CAAC;MACpC,MAAMG,IAAA,GAAcC,IAAA,CAAKC,KAAK,CAACT,GAAA,CAAIG,YAAY,CAACC,GAAG,CAAC,WAAW;MAE/D,IAAI,CAACE,MAAA,IAAU,CAACI,KAAA,CAAMC,OAAO,CAACJ,IAAA,GAAO;QACnC,OAAOR,GAAA,CAAIM,GAAG;MAChB;MAEA,IAAI,OAAOhB,MAAe,CAACiB,MAAA,CAAO,KAAK,YAAY;YACHM,MAAA;QAA9C,IAAIN,MAAA,KAAW,iCAA+BM,MAAA,GAAAL,IAAI,CAAC,EAAE,qBAAPK,MAAA,CAASC,KAAK,GAAE;UAC5DN,IAAI,CAAC,EAAE,GAAG,IAAAO,aAAA,CAAAC,cAAc,EAACR,IAAI,CAAC,EAAE;QAClC;QACA,IAAIS,MAAA,GAAS,MAAM3B,MAAe,CAACiB,MAAA,CAAO,IAAIC,IAAA;QAE9C,IAAIS,MAAA,IAAU,OAAOA,MAAA,KAAW,YAAYA,MAAA,CAAOH,KAAK,EAAE;UACxDG,MAAA,GAAS,IAAAC,OAAA,CAAAC,WAAW,EAACF,MAAA;QACvB;QACAjB,GAAA,CAAIM,GAAG,CAACG,IAAA,CAAKW,SAAS,CAACH,MAAA,IAAU;MACnC;IACF,EAAE,OAAOI,GAAA,EAAU;MACjB,IAAI,IAAAC,QAAA,CAAA7B,OAAO,EAAC4B,GAAA,KAAQA,GAAA,CAAIE,IAAI,KAAK,UAAU;QACzCC,OAAA,CAAQC,KAAK,CAACJ,GAAA;MAChB;MACArB,GAAA,CAAIM,GAAG,CACLG,IAAA,CAAKW,SAAS,CAAC;QACbC,GAAA,EAAK;UAAEK,IAAA,EAAML,GAAA,CAAIK,IAAI;UAAEC,OAAA,EAASN,GAAA,CAAIM,OAAO;UAAEb,KAAA,EAAOO,GAAA,CAAIP;QAAM;MAChE;IAEJ;EACF;EAGF,MAAMc,OAAA,GAAU,MAAM,IAAIC,OAAA,CAAiBC,UAAA;IACzClC,SAAA,CAAUmC,MAAM,CAAC,GAAGzC,MAAA,CAAO0C,QAAQ,EAAE;MACnC,MAAMC,IAAA,GAAOrC,SAAA,CAAUsC,OAAO;MAE9B,IAAID,IAAA,IAAQ,OAAOA,IAAA,KAAS,UAAU;QACpCH,UAAA,CAAWG,IAAA,CAAKE,IAAI;MACtB;IACF;EACF;EAEA,OAAO;IACLP,OAAA;IACAhC,SAAA;IACAL;EACF;AACF"},"metadata":{},"sourceType":"script","externalDependencies":[]}