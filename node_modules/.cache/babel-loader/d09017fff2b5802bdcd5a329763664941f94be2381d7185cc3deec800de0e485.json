{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: function () {\n    return ResponseCache;\n  }\n});\n0 && __export(require(\"./types\"));\nconst _renderresult = /*#__PURE__*/_interop_require_default(require(\"../render-result\"));\n_export_star(require(\"./types\"), exports);\nfunction _export_star(from, to) {\n  Object.keys(from).forEach(function (k) {\n    if (k !== \"default\" && !Object.prototype.hasOwnProperty.call(to, k)) {\n      Object.defineProperty(to, k, {\n        enumerable: true,\n        get: function () {\n          return from[k];\n        }\n      });\n    }\n  });\n  return from;\n}\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nclass ResponseCache {\n  constructor(minimalMode) {\n    this.pendingResponses = new Map();\n    // this is a hack to avoid Webpack knowing this is equal to this.minimalMode\n    // because we replace this.minimalMode to true in production bundles.\n    const minimalModeKey = \"minimalMode\";\n    this[minimalModeKey] = minimalMode;\n  }\n  get(key, responseGenerator, context) {\n    var _this_previousCacheItem;\n    const {\n      incrementalCache\n    } = context;\n    // ensure on-demand revalidate doesn't block normal requests\n    const pendingResponseKey = key ? `${key}-${context.isOnDemandRevalidate ? \"1\" : \"0\"}` : null;\n    const pendingResponse = pendingResponseKey ? this.pendingResponses.get(pendingResponseKey) : null;\n    if (pendingResponse) {\n      return pendingResponse;\n    }\n    let resolver = () => {};\n    let rejecter = () => {};\n    const promise = new Promise((resolve, reject) => {\n      resolver = resolve;\n      rejecter = reject;\n    });\n    if (pendingResponseKey) {\n      this.pendingResponses.set(pendingResponseKey, promise);\n    }\n    let resolved = false;\n    const resolve = cacheEntry => {\n      if (pendingResponseKey) {\n        // Ensure all reads from the cache get the latest value.\n        this.pendingResponses.set(pendingResponseKey, Promise.resolve(cacheEntry));\n      }\n      if (!resolved) {\n        resolved = true;\n        resolver(cacheEntry);\n      }\n    };\n    // we keep the previous cache entry around to leverage\n    // when the incremental cache is disabled in minimal mode\n    if (pendingResponseKey && this.minimalMode && ((_this_previousCacheItem = this.previousCacheItem) == null ? void 0 : _this_previousCacheItem.key) === pendingResponseKey && this.previousCacheItem.expiresAt > Date.now()) {\n      resolve(this.previousCacheItem.entry);\n      this.pendingResponses.delete(pendingResponseKey);\n      return promise;\n    }\n    (async () => {\n      let cachedResponse = null;\n      try {\n        cachedResponse = key && !this.minimalMode ? await incrementalCache.get(key) : null;\n        if (cachedResponse && !context.isOnDemandRevalidate) {\n          var _cachedResponse_value, _cachedResponse_value1;\n          if (((_cachedResponse_value = cachedResponse.value) == null ? void 0 : _cachedResponse_value.kind) === \"FETCH\") {\n            throw new Error(`invariant: unexpected cachedResponse of kind fetch in response cache`);\n          }\n          resolve({\n            isStale: cachedResponse.isStale,\n            revalidate: cachedResponse.curRevalidate,\n            value: ((_cachedResponse_value1 = cachedResponse.value) == null ? void 0 : _cachedResponse_value1.kind) === \"PAGE\" ? {\n              kind: \"PAGE\",\n              html: _renderresult.default.fromStatic(cachedResponse.value.html),\n              pageData: cachedResponse.value.pageData,\n              headers: cachedResponse.value.headers,\n              status: cachedResponse.value.status\n            } : cachedResponse.value\n          });\n          if (!cachedResponse.isStale || context.isPrefetch) {\n            // The cached value is still valid, so we don't need\n            // to update it yet.\n            return;\n          }\n        }\n        const cacheEntry = await responseGenerator(resolved, cachedResponse);\n        const resolveValue = cacheEntry === null ? null : {\n          ...cacheEntry,\n          isMiss: !cachedResponse\n        };\n        // for on-demand revalidate wait to resolve until cache is set\n        if (!context.isOnDemandRevalidate) {\n          resolve(resolveValue);\n        }\n        if (key && cacheEntry && typeof cacheEntry.revalidate !== \"undefined\") {\n          if (this.minimalMode) {\n            this.previousCacheItem = {\n              key: pendingResponseKey || key,\n              entry: cacheEntry,\n              expiresAt: Date.now() + 1000\n            };\n          } else {\n            var _cacheEntry_value;\n            await incrementalCache.set(key, ((_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) === \"PAGE\" ? {\n              kind: \"PAGE\",\n              html: cacheEntry.value.html.toUnchunkedString(),\n              pageData: cacheEntry.value.pageData,\n              headers: cacheEntry.value.headers,\n              status: cacheEntry.value.status\n            } : cacheEntry.value, {\n              revalidate: cacheEntry.revalidate\n            });\n          }\n        } else {\n          this.previousCacheItem = undefined;\n        }\n        if (context.isOnDemandRevalidate) {\n          resolve(resolveValue);\n        }\n      } catch (err) {\n        // when a getStaticProps path is erroring we automatically re-set the\n        // existing cache under a new expiration to prevent non-stop retrying\n        if (cachedResponse && key) {\n          await incrementalCache.set(key, cachedResponse.value, {\n            revalidate: Math.min(Math.max(cachedResponse.revalidate || 3, 3), 30)\n          });\n        }\n        // while revalidating in the background we can't reject as\n        // we already resolved the cache entry so log the error here\n        if (resolved) {\n          console.error(err);\n        } else {\n          rejecter(err);\n        }\n      } finally {\n        if (pendingResponseKey) {\n          this.pendingResponses.delete(pendingResponseKey);\n        }\n      }\n    })();\n    return promise;\n  }\n}","map":{"version":3,"names":["ResponseCache","exports","constructor","minimalMode","pendingResponses","Map","minimalModeKey","get","key","responseGenerator","context","_this_previousCacheItem","incrementalCache","pendingResponseKey","isOnDemandRevalidate","pendingResponse","resolver","rejecter","promise","Promise","resolve","reject","set","resolved","cacheEntry","previousCacheItem","expiresAt","Date","now","entry","delete","cachedResponse","_cachedResponse_value","_cachedResponse_value1","value","kind","Error","isStale","revalidate","curRevalidate","html","_renderresult","default","fromStatic","pageData","headers","status","isPrefetch","resolveValue","isMiss","_cacheEntry_value","toUnchunkedString","undefined","err","Math","min","max","console","error"],"sources":["../../../src/server/response-cache/index.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}