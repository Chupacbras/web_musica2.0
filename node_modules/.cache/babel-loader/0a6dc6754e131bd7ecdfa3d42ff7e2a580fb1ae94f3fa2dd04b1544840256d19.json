{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"createClientRouterFilter\", {\n  enumerable: true,\n  get: function () {\n    return createClientRouterFilter;\n  }\n});\nconst _bloomfilter = require(\"../shared/lib/bloom-filter\");\nconst _utils = require(\"../shared/lib/router/utils\");\nconst _removetrailingslash = require(\"../shared/lib/router/utils/remove-trailing-slash\");\nconst _trytoparsepath = require(\"./try-to-parse-path\");\nfunction createClientRouterFilter(paths, redirects, allowedErrorRate) {\n  const staticPaths = new Set();\n  const dynamicPaths = new Set();\n  for (const path of paths) {\n    if ((0, _utils.isDynamicRoute)(path)) {\n      let subPath = \"\";\n      const pathParts = path.split(\"/\");\n      // start at 1 since we split on '/' and the path starts\n      // with this so the first entry is an empty string\n      for (let i = 1; i < pathParts.length + 1; i++) {\n        const curPart = pathParts[i];\n        if (curPart.startsWith(\"[\")) {\n          break;\n        }\n        subPath = `${subPath}/${curPart}`;\n      }\n      if (subPath) {\n        dynamicPaths.add(subPath);\n      }\n    } else {\n      staticPaths.add(path);\n    }\n  }\n  for (const redirect of redirects) {\n    const {\n      source\n    } = redirect;\n    const path = (0, _removetrailingslash.removeTrailingSlash)(source);\n    let tokens = [];\n    try {\n      tokens = (0, _trytoparsepath.tryToParsePath)(source).tokens || [];\n    } catch {}\n    if (tokens.every(token => typeof token === \"string\")) {\n      // only include static redirects initially\n      staticPaths.add(path);\n    }\n  }\n  const staticFilter = _bloomfilter.BloomFilter.from([...staticPaths], allowedErrorRate);\n  const dynamicFilter = _bloomfilter.BloomFilter.from([...dynamicPaths], allowedErrorRate);\n  const data = {\n    staticFilter: staticFilter.export(),\n    dynamicFilter: dynamicFilter.export()\n  };\n  return data;\n}","map":{"version":3,"names":["createClientRouterFilter","paths","redirects","allowedErrorRate","staticPaths","Set","dynamicPaths","path","_utils","isDynamicRoute","subPath","pathParts","split","i","length","curPart","startsWith","add","redirect","source","_removetrailingslash","removeTrailingSlash","tokens","_trytoparsepath","tryToParsePath","every","token","staticFilter","_bloomfilter","BloomFilter","from","dynamicFilter","data","export"],"sources":["../../src/lib/create-client-router-filter.ts"],"sourcesContent":[null],"mappings":";;;;;+BAOgB;;;WAAAA,wBAAA;;;6BANY;uBACG;qCACK;gCAEL;AAExB,SAASA,yBACdC,KAAe,EACfC,SAAqB,EACrBC,gBAAyB;EAKzB,MAAMC,WAAA,GAAc,IAAIC,GAAA;EACxB,MAAMC,YAAA,GAAe,IAAID,GAAA;EAEzB,KAAK,MAAME,IAAA,IAAQN,KAAA,EAAO;IACxB,IAAI,IAAAO,MAAA,CAAAC,cAAc,EAACF,IAAA,GAAO;MACxB,IAAIG,OAAA,GAAU;MACd,MAAMC,SAAA,GAAYJ,IAAA,CAAKK,KAAK,CAAC;MAE7B;MACA;MACA,KAAK,IAAIC,CAAA,GAAI,GAAGA,CAAA,GAAIF,SAAA,CAAUG,MAAM,GAAG,GAAGD,CAAA,IAAK;QAC7C,MAAME,OAAA,GAAUJ,SAAS,CAACE,CAAA,CAAE;QAE5B,IAAIE,OAAA,CAAQC,UAAU,CAAC,MAAM;UAC3B;QACF;QACAN,OAAA,GAAW,GAAEA,OAAQ,IAAGK,OAAQ,EAAC;MACnC;MAEA,IAAIL,OAAA,EAAS;QACXJ,YAAA,CAAaW,GAAG,CAACP,OAAA;MACnB;IACF,OAAO;MACLN,WAAA,CAAYa,GAAG,CAACV,IAAA;IAClB;EACF;EAEA,KAAK,MAAMW,QAAA,IAAYhB,SAAA,EAAW;IAChC,MAAM;MAAEiB;IAAM,CAAE,GAAGD,QAAA;IACnB,MAAMX,IAAA,GAAO,IAAAa,oBAAA,CAAAC,mBAAmB,EAACF,MAAA;IACjC,IAAIG,MAAA,GAAkB,EAAE;IAExB,IAAI;MACFA,MAAA,GAAS,IAAAC,eAAA,CAAAC,cAAc,EAACL,MAAA,EAAQG,MAAM,IAAI,EAAE;IAC9C,EAAE,MAAM,CAAC;IAET,IAAIA,MAAA,CAAOG,KAAK,CAAEC,KAAA,IAAU,OAAOA,KAAA,KAAU,WAAW;MACtD;MACAtB,WAAA,CAAYa,GAAG,CAACV,IAAA;IAClB;EACF;EAEA,MAAMoB,YAAA,GAAeC,YAAA,CAAAC,WAAW,CAACC,IAAI,CAAC,C,GAAI1B,WAAA,CAAY,EAAED,gBAAA;EAExD,MAAM4B,aAAA,GAAgBH,YAAA,CAAAC,WAAW,CAACC,IAAI,CAAC,C,GAAIxB,YAAA,CAAa,EAAEH,gBAAA;EAC1D,MAAM6B,IAAA,GAAO;IACXL,YAAA,EAAcA,YAAA,CAAaM,MAAM;IACjCF,aAAA,EAAeA,aAAA,CAAcE,MAAM;EACrC;EACA,OAAOD,IAAA;AACT"},"metadata":{},"sourceType":"script","externalDependencies":[]}