{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  EXPORT_NAME_GET_STATIC_PROPS: null,\n  EXPORT_NAME_GET_STATIC_PATHS: null,\n  EXPORT_NAME_GET_SERVER_PROPS: null,\n  default: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  EXPORT_NAME_GET_STATIC_PROPS: function () {\n    return EXPORT_NAME_GET_STATIC_PROPS;\n  },\n  EXPORT_NAME_GET_STATIC_PATHS: function () {\n    return EXPORT_NAME_GET_STATIC_PATHS;\n  },\n  EXPORT_NAME_GET_SERVER_PROPS: function () {\n    return EXPORT_NAME_GET_SERVER_PROPS;\n  },\n  default: function () {\n    return nextTransformSsg;\n  }\n});\nconst _constants = require(\"../../../lib/constants\");\nconst _constants1 = require(\"../../../shared/lib/constants\");\nconst EXPORT_NAME_GET_STATIC_PROPS = \"getStaticProps\";\nconst EXPORT_NAME_GET_STATIC_PATHS = \"getStaticPaths\";\nconst EXPORT_NAME_GET_SERVER_PROPS = \"getServerSideProps\";\nconst ssgExports = new Set([EXPORT_NAME_GET_STATIC_PROPS, EXPORT_NAME_GET_STATIC_PATHS, EXPORT_NAME_GET_SERVER_PROPS,\n// legacy methods added so build doesn't fail from importing\n// server-side only methods\n`unstable_getStaticProps`, `unstable_getStaticPaths`, `unstable_getServerProps`, `unstable_getServerSideProps`]);\nfunction decorateSsgExport(t, path, state) {\n  const gsspName = state.isPrerender ? _constants1.STATIC_PROPS_ID : _constants1.SERVER_PROPS_ID;\n  const gsspId = t.identifier(gsspName);\n  const addGsspExport = exportPath => {\n    if (state.done) {\n      return;\n    }\n    state.done = true;\n    const [pageCompPath] = exportPath.replaceWithMultiple([t.exportNamedDeclaration(t.variableDeclaration(\n    // We use 'var' instead of 'let' or 'const' for ES5 support. Since\n    // this runs in `Program#exit`, no ES2015 transforms (preset env)\n    // will be ran against this code.\n    \"var\", [t.variableDeclarator(gsspId, t.booleanLiteral(true))]), [t.exportSpecifier(gsspId, gsspId)]), exportPath.node]);\n    exportPath.scope.registerDeclaration(pageCompPath);\n  };\n  path.traverse({\n    ExportDefaultDeclaration(exportDefaultPath) {\n      addGsspExport(exportDefaultPath);\n    },\n    ExportNamedDeclaration(exportNamedPath) {\n      addGsspExport(exportNamedPath);\n    }\n  });\n}\nconst isDataIdentifier = (name, state) => {\n  if (ssgExports.has(name)) {\n    if (name === EXPORT_NAME_GET_SERVER_PROPS) {\n      if (state.isPrerender) {\n        throw new Error(_constants.SERVER_PROPS_SSG_CONFLICT);\n      }\n      state.isServerProps = true;\n    } else {\n      if (state.isServerProps) {\n        throw new Error(_constants.SERVER_PROPS_SSG_CONFLICT);\n      }\n      state.isPrerender = true;\n    }\n    return true;\n  }\n  return false;\n};\nfunction nextTransformSsg({\n  types: t\n}) {\n  function getIdentifier(path) {\n    const parentPath = path.parentPath;\n    if (parentPath.type === \"VariableDeclarator\") {\n      const pp = parentPath;\n      const name = pp.get(\"id\");\n      return name.node.type === \"Identifier\" ? name : null;\n    }\n    if (parentPath.type === \"AssignmentExpression\") {\n      const pp = parentPath;\n      const name = pp.get(\"left\");\n      return name.node.type === \"Identifier\" ? name : null;\n    }\n    if (path.node.type === \"ArrowFunctionExpression\") {\n      return null;\n    }\n    return path.node.id && path.node.id.type === \"Identifier\" ? path.get(\"id\") : null;\n  }\n  function isIdentifierReferenced(ident) {\n    const b = ident.scope.getBinding(ident.node.name);\n    if (b == null ? void 0 : b.referenced) {\n      // Functions can reference themselves, so we need to check if there's a\n      // binding outside the function scope or not.\n      if (b.path.type === \"FunctionDeclaration\") {\n        return !b.constantViolations.concat(b.referencePaths) // Check that every reference is contained within the function:\n        .every(ref => ref.findParent(p => p === b.path));\n      }\n      return true;\n    }\n    return false;\n  }\n  function markFunction(path, state) {\n    const ident = getIdentifier(path);\n    if ((ident == null ? void 0 : ident.node) && isIdentifierReferenced(ident)) {\n      state.refs.add(ident);\n    }\n  }\n  function markImport(path, state) {\n    const local = path.get(\"local\");\n    if (isIdentifierReferenced(local)) {\n      state.refs.add(local);\n    }\n  }\n  return {\n    visitor: {\n      Program: {\n        enter(path, state) {\n          state.refs = new Set();\n          state.isPrerender = false;\n          state.isServerProps = false;\n          state.done = false;\n          path.traverse({\n            VariableDeclarator(variablePath, variableState) {\n              if (variablePath.node.id.type === \"Identifier\") {\n                const local = variablePath.get(\"id\");\n                if (isIdentifierReferenced(local)) {\n                  variableState.refs.add(local);\n                }\n              } else if (variablePath.node.id.type === \"ObjectPattern\") {\n                const pattern = variablePath.get(\"id\");\n                const properties = pattern.get(\"properties\");\n                properties.forEach(p => {\n                  const local = p.get(p.node.type === \"ObjectProperty\" ? \"value\" : p.node.type === \"RestElement\" ? \"argument\" : function () {\n                    throw new Error(\"invariant\");\n                  }());\n                  if (isIdentifierReferenced(local)) {\n                    variableState.refs.add(local);\n                  }\n                });\n              } else if (variablePath.node.id.type === \"ArrayPattern\") {\n                const pattern = variablePath.get(\"id\");\n                const elements = pattern.get(\"elements\");\n                elements.forEach(e => {\n                  var _e_node, _e_node1;\n                  let local;\n                  if (((_e_node = e.node) == null ? void 0 : _e_node.type) === \"Identifier\") {\n                    local = e;\n                  } else if (((_e_node1 = e.node) == null ? void 0 : _e_node1.type) === \"RestElement\") {\n                    local = e.get(\"argument\");\n                  } else {\n                    return;\n                  }\n                  if (isIdentifierReferenced(local)) {\n                    variableState.refs.add(local);\n                  }\n                });\n              }\n            },\n            FunctionDeclaration: markFunction,\n            FunctionExpression: markFunction,\n            ArrowFunctionExpression: markFunction,\n            ImportSpecifier: markImport,\n            ImportDefaultSpecifier: markImport,\n            ImportNamespaceSpecifier: markImport,\n            ExportNamedDeclaration(exportNamedPath, exportNamedState) {\n              const specifiers = exportNamedPath.get(\"specifiers\");\n              if (specifiers.length) {\n                specifiers.forEach(s => {\n                  if (isDataIdentifier(t.isIdentifier(s.node.exported) ? s.node.exported.name : s.node.exported.value, exportNamedState)) {\n                    s.remove();\n                  }\n                });\n                if (exportNamedPath.node.specifiers.length < 1) {\n                  exportNamedPath.remove();\n                }\n                return;\n              }\n              const decl = exportNamedPath.get(\"declaration\");\n              if (decl == null || decl.node == null) {\n                return;\n              }\n              switch (decl.node.type) {\n                case \"FunctionDeclaration\":\n                  {\n                    const name = decl.node.id.name;\n                    if (isDataIdentifier(name, exportNamedState)) {\n                      exportNamedPath.remove();\n                    }\n                    break;\n                  }\n                case \"VariableDeclaration\":\n                  {\n                    const inner = decl.get(\"declarations\");\n                    inner.forEach(d => {\n                      if (d.node.id.type !== \"Identifier\") {\n                        return;\n                      }\n                      const name = d.node.id.name;\n                      if (isDataIdentifier(name, exportNamedState)) {\n                        d.remove();\n                      }\n                    });\n                    break;\n                  }\n                default:\n                  {\n                    break;\n                  }\n              }\n            }\n          }, state);\n          if (!state.isPrerender && !state.isServerProps) {\n            return;\n          }\n          const refs = state.refs;\n          let count;\n          function sweepFunction(sweepPath) {\n            const ident = getIdentifier(sweepPath);\n            if ((ident == null ? void 0 : ident.node) && refs.has(ident) && !isIdentifierReferenced(ident)) {\n              ++count;\n              if (t.isAssignmentExpression(sweepPath.parentPath) || t.isVariableDeclarator(sweepPath.parentPath)) {\n                sweepPath.parentPath.remove();\n              } else {\n                sweepPath.remove();\n              }\n            }\n          }\n          function sweepImport(sweepPath) {\n            const local = sweepPath.get(\"local\");\n            if (refs.has(local) && !isIdentifierReferenced(local)) {\n              ++count;\n              sweepPath.remove();\n              if (sweepPath.parent.specifiers.length === 0) {\n                sweepPath.parentPath.remove();\n              }\n            }\n          }\n          do {\n            path.scope.crawl();\n            count = 0;\n            path.traverse({\n              // eslint-disable-next-line no-loop-func\n              VariableDeclarator(variablePath) {\n                if (variablePath.node.id.type === \"Identifier\") {\n                  const local = variablePath.get(\"id\");\n                  if (refs.has(local) && !isIdentifierReferenced(local)) {\n                    ++count;\n                    variablePath.remove();\n                  }\n                } else if (variablePath.node.id.type === \"ObjectPattern\") {\n                  const pattern = variablePath.get(\"id\");\n                  const beforeCount = count;\n                  const properties = pattern.get(\"properties\");\n                  properties.forEach(p => {\n                    const local = p.get(p.node.type === \"ObjectProperty\" ? \"value\" : p.node.type === \"RestElement\" ? \"argument\" : function () {\n                      throw new Error(\"invariant\");\n                    }());\n                    if (refs.has(local) && !isIdentifierReferenced(local)) {\n                      ++count;\n                      p.remove();\n                    }\n                  });\n                  if (beforeCount !== count && pattern.get(\"properties\").length < 1) {\n                    variablePath.remove();\n                  }\n                } else if (variablePath.node.id.type === \"ArrayPattern\") {\n                  const pattern = variablePath.get(\"id\");\n                  const beforeCount = count;\n                  const elements = pattern.get(\"elements\");\n                  elements.forEach(e => {\n                    var _e_node, _e_node1;\n                    let local;\n                    if (((_e_node = e.node) == null ? void 0 : _e_node.type) === \"Identifier\") {\n                      local = e;\n                    } else if (((_e_node1 = e.node) == null ? void 0 : _e_node1.type) === \"RestElement\") {\n                      local = e.get(\"argument\");\n                    } else {\n                      return;\n                    }\n                    if (refs.has(local) && !isIdentifierReferenced(local)) {\n                      ++count;\n                      e.remove();\n                    }\n                  });\n                  if (beforeCount !== count && pattern.get(\"elements\").length < 1) {\n                    variablePath.remove();\n                  }\n                }\n              },\n              FunctionDeclaration: sweepFunction,\n              FunctionExpression: sweepFunction,\n              ArrowFunctionExpression: sweepFunction,\n              ImportSpecifier: sweepImport,\n              ImportDefaultSpecifier: sweepImport,\n              ImportNamespaceSpecifier: sweepImport\n            });\n          } while (count);\n          decorateSsgExport(t, path, state);\n        }\n      }\n    }\n  };\n}","map":{"version":3,"names":["EXPORT_NAME_GET_STATIC_PROPS","EXPORT_NAME_GET_STATIC_PATHS","EXPORT_NAME_GET_SERVER_PROPS","default","nextTransformSsg","ssgExports","Set","decorateSsgExport","t","path","state","gsspName","isPrerender","_constants1","STATIC_PROPS_ID","SERVER_PROPS_ID","gsspId","identifier","addGsspExport","exportPath","done","pageCompPath","replaceWithMultiple","exportNamedDeclaration","variableDeclaration","variableDeclarator","booleanLiteral","exportSpecifier","node","scope","registerDeclaration","traverse","ExportDefaultDeclaration","exportDefaultPath","ExportNamedDeclaration","exportNamedPath","isDataIdentifier","name","has","Error","_constants","SERVER_PROPS_SSG_CONFLICT","isServerProps","types","getIdentifier","parentPath","type","pp","get","id","isIdentifierReferenced","ident","b","getBinding","referenced","constantViolations","concat","referencePaths","every","ref","findParent","p","markFunction","refs","add","markImport","local","visitor","Program","enter","VariableDeclarator","variablePath","variableState","pattern","properties","forEach","elements","e","_e_node","_e_node1","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","ImportSpecifier","ImportDefaultSpecifier","ImportNamespaceSpecifier","exportNamedState","specifiers","length","s","isIdentifier","exported","value","remove","decl","inner","d","count","sweepFunction","sweepPath","isAssignmentExpression","isVariableDeclarator","sweepImport","parent","crawl","beforeCount"],"sources":["../../../../src/build/babel/plugins/next-ssg-transform.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}