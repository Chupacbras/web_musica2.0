{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: function () {\n    return FileSystemCache;\n  }\n});\nconst _lrucache = /*#__PURE__*/_interop_require_default(require(\"next/dist/compiled/lru-cache\"));\nconst _path = /*#__PURE__*/_interop_require_default(require(\"../../../shared/lib/isomorphic/path\"));\nconst _constants = require(\"../../../lib/constants\");\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nlet memoryCache;\nlet tagsManifest;\nclass FileSystemCache {\n  constructor(ctx) {\n    this.fs = ctx.fs;\n    this.flushToDisk = ctx.flushToDisk;\n    this.serverDistDir = ctx.serverDistDir;\n    this.appDir = !!ctx._appDir;\n    this.revalidatedTags = ctx.revalidatedTags;\n    if (ctx.maxMemoryCacheSize && !memoryCache) {\n      memoryCache = new _lrucache.default({\n        max: ctx.maxMemoryCacheSize,\n        length({\n          value\n        }) {\n          var _JSON_stringify;\n          if (!value) {\n            return 25;\n          } else if (value.kind === \"REDIRECT\") {\n            return JSON.stringify(value.props).length;\n          } else if (value.kind === \"IMAGE\") {\n            throw new Error(\"invariant image should not be incremental-cache\");\n          } else if (value.kind === \"FETCH\") {\n            return JSON.stringify(value.data || \"\").length;\n          } else if (value.kind === \"ROUTE\") {\n            return value.body.length;\n          }\n          // rough estimate of size of cache value\n          return value.html.length + (((_JSON_stringify = JSON.stringify(value.pageData)) == null ? void 0 : _JSON_stringify.length) || 0);\n        }\n      });\n    }\n    if (this.serverDistDir && this.fs) {\n      this.tagsManifestPath = _path.default.join(this.serverDistDir, \"..\", \"cache\", \"fetch-cache\", \"tags-manifest.json\");\n      this.loadTagsManifest();\n    }\n  }\n  loadTagsManifest() {\n    if (!this.tagsManifestPath || !this.fs || tagsManifest) return;\n    try {\n      tagsManifest = JSON.parse(this.fs.readFileSync(this.tagsManifestPath).toString(\"utf8\"));\n    } catch (err) {\n      tagsManifest = {\n        version: 1,\n        items: {}\n      };\n    }\n  }\n  async revalidateTag(tag) {\n    // we need to ensure the tagsManifest is refreshed\n    // since separate workers can be updating it at the same\n    // time and we can't flush out of sync data\n    this.loadTagsManifest();\n    if (!tagsManifest || !this.tagsManifestPath) {\n      return;\n    }\n    const data = tagsManifest.items[tag] || {};\n    data.revalidatedAt = Date.now();\n    tagsManifest.items[tag] = data;\n    try {\n      await this.fs.mkdir(_path.default.dirname(this.tagsManifestPath));\n      await this.fs.writeFile(this.tagsManifestPath, JSON.stringify(tagsManifest || {}));\n    } catch (err) {\n      console.warn(\"Failed to update tags manifest.\", err);\n    }\n  }\n  async get(key, {\n    tags,\n    softTags,\n    fetchCache\n  } = {}) {\n    var _data_value, _data_value1;\n    let data = memoryCache == null ? void 0 : memoryCache.get(key);\n    // let's check the disk for seed data\n    if (!data && process.env.NEXT_RUNTIME !== \"edge\") {\n      try {\n        const {\n          filePath\n        } = await this.getFsPath({\n          pathname: `${key}.body`,\n          appDir: true\n        });\n        const fileData = await this.fs.readFile(filePath);\n        const {\n          mtime\n        } = await this.fs.stat(filePath);\n        const meta = JSON.parse((await this.fs.readFile(filePath.replace(/\\.body$/, \".meta\"))).toString(\"utf8\"));\n        const cacheEntry = {\n          lastModified: mtime.getTime(),\n          value: {\n            kind: \"ROUTE\",\n            body: fileData,\n            headers: meta.headers,\n            status: meta.status\n          }\n        };\n        return cacheEntry;\n      } catch (_) {\n        // no .meta data for the related key\n      }\n      try {\n        const {\n          filePath,\n          isAppPath\n        } = await this.getFsPath({\n          pathname: fetchCache ? key : `${key}.html`,\n          fetchCache\n        });\n        const fileData = (await this.fs.readFile(filePath)).toString(\"utf-8\");\n        const {\n          mtime\n        } = await this.fs.stat(filePath);\n        if (fetchCache) {\n          var _data_value2;\n          const lastModified = mtime.getTime();\n          const parsedData = JSON.parse(fileData);\n          data = {\n            lastModified,\n            value: parsedData\n          };\n          if (((_data_value2 = data.value) == null ? void 0 : _data_value2.kind) === \"FETCH\") {\n            var _data_value_data, _data_value3;\n            const storedTags = (_data_value3 = data.value) == null ? void 0 : (_data_value_data = _data_value3.data) == null ? void 0 : _data_value_data.tags;\n            // update stored tags if a new one is being added\n            // TODO: remove this when we can send the tags\n            // via header on GET same as SET\n            if (!(tags == null ? void 0 : tags.every(tag => storedTags == null ? void 0 : storedTags.includes(tag)))) {\n              await this.set(key, data.value, {\n                tags\n              });\n            }\n          }\n        } else {\n          const pageData = isAppPath ? (await this.fs.readFile((await this.getFsPath({\n            pathname: `${key}.rsc`,\n            appDir: true\n          })).filePath)).toString(\"utf8\") : JSON.parse((await this.fs.readFile((await this.getFsPath({\n            pathname: `${key}.json`,\n            appDir: false\n          })).filePath)).toString(\"utf8\"));\n          let meta = {};\n          if (isAppPath) {\n            try {\n              meta = JSON.parse((await this.fs.readFile(filePath.replace(/\\.html$/, \".meta\"))).toString(\"utf-8\"));\n            } catch {}\n          }\n          data = {\n            lastModified: mtime.getTime(),\n            value: {\n              kind: \"PAGE\",\n              html: fileData,\n              pageData,\n              headers: meta.headers,\n              status: meta.status\n            }\n          };\n        }\n        if (data) {\n          memoryCache == null ? void 0 : memoryCache.set(key, data);\n        }\n      } catch (_) {\n        // unable to get data from disk\n      }\n    }\n    if ((data == null ? void 0 : (_data_value = data.value) == null ? void 0 : _data_value.kind) === \"PAGE\") {\n      var _data_value_headers;\n      let cacheTags;\n      const tagsHeader = (_data_value_headers = data.value.headers) == null ? void 0 : _data_value_headers[_constants.NEXT_CACHE_TAGS_HEADER];\n      if (typeof tagsHeader === \"string\") {\n        cacheTags = tagsHeader.split(\",\");\n      }\n      if (cacheTags == null ? void 0 : cacheTags.length) {\n        this.loadTagsManifest();\n        const isStale = cacheTags.some(tag => {\n          var _tagsManifest_items_tag;\n          return (tagsManifest == null ? void 0 : (_tagsManifest_items_tag = tagsManifest.items[tag]) == null ? void 0 : _tagsManifest_items_tag.revalidatedAt) && (tagsManifest == null ? void 0 : tagsManifest.items[tag].revalidatedAt) >= ((data == null ? void 0 : data.lastModified) || Date.now());\n        });\n        // we trigger a blocking validation if an ISR page\n        // had a tag revalidated, if we want to be a background\n        // revalidation instead we return data.lastModified = -1\n        if (isStale) {\n          data = undefined;\n        }\n      }\n    }\n    if (data && (data == null ? void 0 : (_data_value1 = data.value) == null ? void 0 : _data_value1.kind) === \"FETCH\") {\n      this.loadTagsManifest();\n      const combinedTags = [...(tags || []), ...(softTags || [])];\n      const wasRevalidated = combinedTags.some(tag => {\n        var _tagsManifest_items_tag;\n        if (this.revalidatedTags.includes(tag)) {\n          return true;\n        }\n        return (tagsManifest == null ? void 0 : (_tagsManifest_items_tag = tagsManifest.items[tag]) == null ? void 0 : _tagsManifest_items_tag.revalidatedAt) && (tagsManifest == null ? void 0 : tagsManifest.items[tag].revalidatedAt) >= ((data == null ? void 0 : data.lastModified) || Date.now());\n      });\n      // When revalidate tag is called we don't return\n      // stale data so it's updated right away\n      if (wasRevalidated) {\n        data = undefined;\n      }\n    }\n    return data || null;\n  }\n  async set(key, data, ctx) {\n    memoryCache == null ? void 0 : memoryCache.set(key, {\n      value: data,\n      lastModified: Date.now()\n    });\n    if (!this.flushToDisk) return;\n    if ((data == null ? void 0 : data.kind) === \"ROUTE\") {\n      const {\n        filePath\n      } = await this.getFsPath({\n        pathname: `${key}.body`,\n        appDir: true\n      });\n      await this.fs.mkdir(_path.default.dirname(filePath));\n      await this.fs.writeFile(filePath, data.body);\n      await this.fs.writeFile(filePath.replace(/\\.body$/, \".meta\"), JSON.stringify({\n        headers: data.headers,\n        status: data.status\n      }));\n      return;\n    }\n    if ((data == null ? void 0 : data.kind) === \"PAGE\") {\n      const isAppPath = typeof data.pageData === \"string\";\n      const {\n        filePath: htmlPath\n      } = await this.getFsPath({\n        pathname: `${key}.html`,\n        appDir: isAppPath\n      });\n      await this.fs.mkdir(_path.default.dirname(htmlPath));\n      await this.fs.writeFile(htmlPath, data.html);\n      await this.fs.writeFile((await this.getFsPath({\n        pathname: `${key}.${isAppPath ? \"rsc\" : \"json\"}`,\n        appDir: isAppPath\n      })).filePath, isAppPath ? data.pageData : JSON.stringify(data.pageData));\n      if (data.headers || data.status) {\n        await this.fs.writeFile(htmlPath.replace(/\\.html$/, \".meta\"), JSON.stringify({\n          headers: data.headers,\n          status: data.status\n        }));\n      }\n    } else if ((data == null ? void 0 : data.kind) === \"FETCH\") {\n      const {\n        filePath\n      } = await this.getFsPath({\n        pathname: key,\n        fetchCache: true\n      });\n      await this.fs.mkdir(_path.default.dirname(filePath));\n      await this.fs.writeFile(filePath, JSON.stringify({\n        ...data,\n        tags: ctx.tags\n      }));\n    }\n  }\n  async getFsPath({\n    pathname,\n    appDir,\n    fetchCache\n  }) {\n    if (fetchCache) {\n      // we store in .next/cache/fetch-cache so it can be persisted\n      // across deploys\n      return {\n        filePath: _path.default.join(this.serverDistDir, \"..\", \"cache\", \"fetch-cache\", pathname),\n        isAppPath: false\n      };\n    }\n    let isAppPath = false;\n    let filePath = _path.default.join(this.serverDistDir, \"pages\", pathname);\n    if (!this.appDir || appDir === false) return {\n      filePath,\n      isAppPath\n    };\n    try {\n      await this.fs.readFile(filePath);\n      return {\n        filePath,\n        isAppPath\n      };\n    } catch (err) {\n      return {\n        filePath: _path.default.join(this.serverDistDir, \"app\", pathname),\n        isAppPath: true\n      };\n    }\n  }\n}","map":{"version":3,"names":["FileSystemCache","memoryCache","tagsManifest","constructor","ctx","fs","flushToDisk","serverDistDir","appDir","_appDir","revalidatedTags","maxMemoryCacheSize","_lrucache","default","max","length","value","_JSON_stringify","kind","JSON","stringify","props","Error","data","body","html","pageData","tagsManifestPath","_path","join","loadTagsManifest","parse","readFileSync","toString","err","version","items","revalidateTag","tag","revalidatedAt","Date","now","mkdir","dirname","writeFile","console","warn","get","key","tags","softTags","fetchCache","_data_value","_data_value1","process","env","NEXT_RUNTIME","filePath","getFsPath","pathname","fileData","readFile","mtime","stat","meta","replace","cacheEntry","lastModified","getTime","headers","status","_","isAppPath","_data_value2","parsedData","_data_value_data","_data_value3","storedTags","every","includes","set","_data_value_headers","cacheTags","tagsHeader","_constants","NEXT_CACHE_TAGS_HEADER","split","isStale","some","_tagsManifest_items_tag","undefined","combinedTags","wasRevalidated","htmlPath"],"sources":["../../../../src/server/lib/incremental-cache/file-system-cache.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}