{"ast":null,"code":"\"use strict\";\n\n/**\n * Callback function for sorting font variant values.\n * Used as a parameter in `Array.prototype.sort` function to ensure correct sorting.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sortFontsVariantValues = void 0;\nfunction sortFontsVariantValues(valA, valB) {\n  // If both values contain commas, it indicates they are in \"ital,wght\" format\n  if (valA.includes(',') && valB.includes(',')) {\n    // Split the values into prefix and suffix\n    const [aPrefix, aSuffix] = valA.split(',');\n    const [bPrefix, bSuffix] = valB.split(',');\n    // Compare the prefixes (ital values)\n    if (aPrefix === bPrefix) {\n      // If prefixes are equal, then compare the suffixes (wght values)\n      return parseInt(aSuffix) - parseInt(bSuffix);\n    } else {\n      // If prefixes are different, then compare the prefixes directly\n      return parseInt(aPrefix) - parseInt(bPrefix);\n    }\n  }\n  // If values are not in \"ital,wght\" format, then directly compare them as integers\n  return parseInt(valA) - parseInt(valB);\n}\nexports.sortFontsVariantValues = sortFontsVariantValues;","map":{"version":3,"names":["Object","defineProperty","exports","value","sortFontsVariantValues","valA","valB","includes","aPrefix","aSuffix","split","bPrefix","bSuffix","parseInt"],"sources":["/Users/albertformatger/Documents/GitHub/web_musica/node_modules/next/dist/compiled/@next/font/dist/google/sort-fonts-variant-values.js"],"sourcesContent":["\"use strict\";\n/**\n * Callback function for sorting font variant values.\n * Used as a parameter in `Array.prototype.sort` function to ensure correct sorting.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sortFontsVariantValues = void 0;\nfunction sortFontsVariantValues(valA, valB) {\n    // If both values contain commas, it indicates they are in \"ital,wght\" format\n    if (valA.includes(',') && valB.includes(',')) {\n        // Split the values into prefix and suffix\n        const [aPrefix, aSuffix] = valA.split(',');\n        const [bPrefix, bSuffix] = valB.split(',');\n        // Compare the prefixes (ital values)\n        if (aPrefix === bPrefix) {\n            // If prefixes are equal, then compare the suffixes (wght values)\n            return parseInt(aSuffix) - parseInt(bSuffix);\n        }\n        else {\n            // If prefixes are different, then compare the prefixes directly\n            return parseInt(aPrefix) - parseInt(bPrefix);\n        }\n    }\n    // If values are not in \"ital,wght\" format, then directly compare them as integers\n    return parseInt(valA) - parseInt(valB);\n}\nexports.sortFontsVariantValues = sortFontsVariantValues;\n"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,sBAAsB,GAAG,KAAK,CAAC;AACvC,SAASA,sBAAsBA,CAACC,IAAI,EAAEC,IAAI,EAAE;EACxC;EACA,IAAID,IAAI,CAACE,QAAQ,CAAC,GAAG,CAAC,IAAID,IAAI,CAACC,QAAQ,CAAC,GAAG,CAAC,EAAE;IAC1C;IACA,MAAM,CAACC,OAAO,EAAEC,OAAO,CAAC,GAAGJ,IAAI,CAACK,KAAK,CAAC,GAAG,CAAC;IAC1C,MAAM,CAACC,OAAO,EAAEC,OAAO,CAAC,GAAGN,IAAI,CAACI,KAAK,CAAC,GAAG,CAAC;IAC1C;IACA,IAAIF,OAAO,KAAKG,OAAO,EAAE;MACrB;MACA,OAAOE,QAAQ,CAACJ,OAAO,CAAC,GAAGI,QAAQ,CAACD,OAAO,CAAC;IAChD,CAAC,MACI;MACD;MACA,OAAOC,QAAQ,CAACL,OAAO,CAAC,GAAGK,QAAQ,CAACF,OAAO,CAAC;IAChD;EACJ;EACA;EACA,OAAOE,QAAQ,CAACR,IAAI,CAAC,GAAGQ,QAAQ,CAACP,IAAI,CAAC;AAC1C;AACAJ,OAAO,CAACE,sBAAsB,GAAGA,sBAAsB"},"metadata":{},"sourceType":"script","externalDependencies":[]}