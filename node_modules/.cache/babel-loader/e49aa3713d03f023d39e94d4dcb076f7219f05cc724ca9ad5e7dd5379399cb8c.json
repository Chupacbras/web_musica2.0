{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  fillMetadataSegment: null,\n  normalizeMetadataRoute: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  fillMetadataSegment: function () {\n    return fillMetadataSegment;\n  },\n  normalizeMetadataRoute: function () {\n    return normalizeMetadataRoute;\n  }\n});\nconst _ismetadataroute = require(\"./is-metadata-route\");\nconst _path = /*#__PURE__*/_interop_require_default(require(\"../../shared/lib/isomorphic/path\"));\nconst _serverutils = require(\"../../server/server-utils\");\nconst _routeregex = require(\"../../shared/lib/router/utils/route-regex\");\nconst _hash = require(\"../../shared/lib/hash\");\nconst _apppaths = require(\"../../shared/lib/router/utils/app-paths\");\nconst _normalizepathsep = require(\"../../shared/lib/page-path/normalize-path-sep\");\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/*\n * If there's special convention like (...) or @ in the page path,\n * Give it a unique hash suffix to avoid conflicts\n *\n * e.g.\n * /app/open-graph.tsx -> /open-graph/route\n * /app/(post)/open-graph.tsx -> /open-graph/route-[0-9a-z]{6}\n */\nfunction getMetadataRouteSuffix(page) {\n  let suffix = \"\";\n  if (page.includes(\"(\") && page.includes(\")\") || page.includes(\"@\")) {\n    suffix = (0, _hash.djb2Hash)(page).toString(36).slice(0, 6);\n  }\n  return suffix;\n}\nfunction fillMetadataSegment(segment, params, imageSegment) {\n  const pathname = (0, _apppaths.normalizeAppPath)(segment);\n  const routeRegex = (0, _routeregex.getNamedRouteRegex)(pathname, false);\n  const route = (0, _serverutils.interpolateDynamicPath)(pathname, params, routeRegex);\n  const suffix = getMetadataRouteSuffix(segment);\n  const routeSuffix = suffix ? `-${suffix}` : \"\";\n  const {\n    name,\n    ext\n  } = _path.default.parse(imageSegment);\n  return (0, _normalizepathsep.normalizePathSep)(_path.default.join(route, `${name}${routeSuffix}${ext}`));\n}\nfunction normalizeMetadataRoute(page) {\n  if (!(0, _ismetadataroute.isMetadataRoute)(page)) {\n    return page;\n  }\n  let route = page;\n  let suffix = \"\";\n  if (page === \"/robots\") {\n    route += \".txt\";\n  } else if (page === \"/manifest\") {\n    route += \".webmanifest\";\n  } else if (page.endsWith(\"/sitemap\")) {\n    route += \".xml\";\n  } else {\n    // Remove the file extension, e.g. /route-path/robots.txt -> /route-path\n    const pathnamePrefix = page.slice(0, -(_path.default.basename(page).length + 1));\n    suffix = getMetadataRouteSuffix(pathnamePrefix);\n  }\n  // Support both /<metadata-route.ext> and custom routes /<metadata-route>/route.ts.\n  // If it's a metadata file route, we need to append /[id]/route to the page.\n  if (!route.endsWith(\"/route\")) {\n    const {\n      dir,\n      name: baseName,\n      ext\n    } = _path.default.parse(route);\n    const isStaticRoute = (0, _ismetadataroute.isStaticMetadataRoute)(page);\n    route = _path.default.posix.join(dir, `${baseName}${suffix ? `-${suffix}` : \"\"}${ext}`, isStaticRoute ? \"\" : \"[[...__metadata_id__]]\", \"route\");\n  }\n  return route;\n}","map":{"version":3,"names":["fillMetadataSegment","normalizeMetadataRoute","getMetadataRouteSuffix","page","suffix","includes","_hash","djb2Hash","toString","slice","segment","params","imageSegment","pathname","_apppaths","normalizeAppPath","routeRegex","_routeregex","getNamedRouteRegex","route","_serverutils","interpolateDynamicPath","routeSuffix","name","ext","_path","default","parse","_normalizepathsep","normalizePathSep","join","_ismetadataroute","isMetadataRoute","endsWith","pathnamePrefix","basename","length","dir","baseName","isStaticRoute","isStaticMetadataRoute","posix"],"sources":["../../../src/lib/metadata/get-metadata-route.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;;;EAgCgBA,mBAAmB,WAAAA,CAAA;WAAnBA,mBAAA;;EAyBAC,sBAAsB,WAAAA,CAAA;WAAtBA,sBAAA;;;iCAzDuC;4DACtC;6BACsB;4BACJ;sBACV;0BACQ;kCACA;;;;;;AAEjC;;;;;;;;AAQA,SAASC,uBAAuBC,IAAY;EAC1C,IAAIC,MAAA,GAAS;EAEb,IAAID,IAAC,CAAKE,QAAQ,CAAC,QAAQF,IAAA,CAAKE,QAAQ,CAAC,QAASF,IAAA,CAAKE,QAAQ,CAAC,MAAM;IACpED,MAAA,GAAS,IAAAE,KAAA,CAAAC,QAAQ,EAACJ,IAAA,EAAMK,QAAQ,CAAC,IAAIC,KAAK,CAAC,GAAG;EAChD;EACA,OAAOL,MAAA;AACT;AASO,SAASJ,oBACdU,OAAe,EACfC,MAAW,EACXC,YAAoB;EAEpB,MAAMC,QAAA,GAAW,IAAAC,SAAA,CAAAC,gBAAgB,EAACL,OAAA;EAClC,MAAMM,UAAA,GAAa,IAAAC,WAAA,CAAAC,kBAAkB,EAACL,QAAA,EAAU;EAChD,MAAMM,KAAA,GAAQ,IAAAC,YAAA,CAAAC,sBAAsB,EAACR,QAAA,EAAUF,MAAA,EAAQK,UAAA;EACvD,MAAMZ,MAAA,GAASF,sBAAA,CAAuBQ,OAAA;EACtC,MAAMY,WAAA,GAAclB,MAAA,GAAU,IAAGA,MAAO,EAAC,GAAG;EAE5C,MAAM;IAAEmB,IAAI;IAAEC;EAAG,CAAE,GAAGC,KAAA,CAAAC,OAAI,CAACC,KAAK,CAACf,YAAA;EAEjC,OAAO,IAAAgB,iBAAA,CAAAC,gBAAgB,EAACJ,KAAA,CAAAC,OAAI,CAACI,IAAI,CAACX,KAAA,EAAQ,GAAEI,IAAK,GAAED,WAAY,GAAEE,GAAI,EAAC;AACxE;AAWO,SAASvB,uBAAuBE,IAAY;EACjD,IAAI,CAAC,IAAA4B,gBAAA,CAAAC,eAAe,EAAC7B,IAAA,GAAO;IAC1B,OAAOA,IAAA;EACT;EACA,IAAIgB,KAAA,GAAQhB,IAAA;EACZ,IAAIC,MAAA,GAAS;EACb,IAAID,IAAA,KAAS,WAAW;IACtBgB,KAAA,IAAS;EACX,OAAO,IAAIhB,IAAA,KAAS,aAAa;IAC/BgB,KAAA,IAAS;EACX,OAAO,IAAIhB,IAAA,CAAK8B,QAAQ,CAAC,aAAa;IACpCd,KAAA,IAAS;EACX,OAAO;IACL;IACA,MAAMe,cAAA,GAAiB/B,IAAA,CAAKM,KAAK,CAAC,GAAG,EAAEgB,KAAA,CAAAC,OAAI,CAACS,QAAQ,CAAChC,IAAA,EAAMiC,MAAM,GAAG;IACpEhC,MAAA,GAASF,sBAAA,CAAuBgC,cAAA;EAClC;EACA;EACA;EACA,IAAI,CAACf,KAAA,CAAMc,QAAQ,CAAC,WAAW;IAC7B,MAAM;MAAEI,GAAG;MAAEd,IAAA,EAAMe,QAAQ;MAAEd;IAAG,CAAE,GAAGC,KAAA,CAAAC,OAAI,CAACC,KAAK,CAACR,KAAA;IAChD,MAAMoB,aAAA,GAAgB,IAAAR,gBAAA,CAAAS,qBAAqB,EAACrC,IAAA;IAE5CgB,KAAA,GAAQM,KAAA,CAAAC,OAAI,CAACe,KAAK,CAACX,IAAI,CACrBO,GAAA,EACC,GAAEC,QAAS,GAAElC,MAAA,GAAU,IAAGA,MAAO,EAAC,GAAG,EAAG,GAAEoB,GAAI,EAAC,EAChDe,aAAA,GAAgB,KAAK,0BACrB;EAEJ;EAEA,OAAOpB,KAAA;AACT"},"metadata":{},"sourceType":"script","externalDependencies":[]}