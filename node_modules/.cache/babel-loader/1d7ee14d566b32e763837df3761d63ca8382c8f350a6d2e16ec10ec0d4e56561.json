{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fetchCSSFromGoogleFonts = void 0;\n// @ts-ignore\nconst node_fetch_1 = __importDefault(require(\"next/dist/compiled/node-fetch\"));\nconst next_font_error_1 = require(\"../next-font-error\");\nconst get_proxy_agent_1 = require(\"./get-proxy-agent\");\nasync function retry(fn, attempts) {\n  let cnt = attempts;\n  while (true) {\n    try {\n      return await fn();\n    } catch (err) {\n      cnt--;\n      if (cnt <= 0) throw err;\n      console.error(err.message + `\\n\\nRetrying ${attempts - cnt}/3...`);\n      await new Promise(resolve => setTimeout(resolve, 100));\n    }\n  }\n}\n/**\n * Fetches the CSS containing the @font-face declarations from Google Fonts.\n * The fetch has a user agent header with a modern browser to ensure we'll get .woff2 files.\n *\n * The env variable NEXT_FONT_GOOGLE_MOCKED_RESPONSES may be set containing a path to mocked data.\n * It's used to define mocked data to avoid hitting the Google Fonts API during tests.\n */\nasync function fetchCSSFromGoogleFonts(url, fontFamily, isDev) {\n  // Check if mocked responses are defined, if so use them instead of fetching from Google Fonts\n  let mockedResponse;\n  if (process.env.NEXT_FONT_GOOGLE_MOCKED_RESPONSES) {\n    const mockFile = require(process.env.NEXT_FONT_GOOGLE_MOCKED_RESPONSES);\n    mockedResponse = mockFile[url];\n    if (!mockedResponse) {\n      (0, next_font_error_1.nextFontError)('Missing mocked response for URL: ' + url);\n    }\n  }\n  let cssResponse;\n  if (mockedResponse) {\n    // Just use the mocked CSS if it's set\n    cssResponse = mockedResponse;\n  } else {\n    // Retry the fetch a few times in case of network issues as some font files\n    // are quite large:\n    // https://github.com/vercel/next.js/issues/45080\n    cssResponse = await retry(async () => {\n      const controller = isDev && typeof AbortController !== 'undefined' ? new AbortController() : undefined;\n      const signal = controller === null || controller === void 0 ? void 0 : controller.signal;\n      const timeoutId = controller ? setTimeout(() => controller.abort(), 3000) : undefined;\n      const res = await (0, node_fetch_1.default)(url, {\n        agent: (0, get_proxy_agent_1.getProxyAgent)(),\n        // Add a timeout in dev\n        signal,\n        headers: {\n          // The file format is based off of the user agent, make sure woff2 files are fetched\n          'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36'\n        }\n      }).finally(() => {\n        timeoutId && clearTimeout(timeoutId);\n      });\n      if (!res.ok) {\n        (0, next_font_error_1.nextFontError)(`Failed to fetch font \\`${fontFamily}\\`.\\nURL: ${url}\\n\\nPlease check if the network is available.`);\n      }\n      return res.text();\n    }, 3);\n  }\n  return cssResponse;\n}\nexports.fetchCSSFromGoogleFonts = fetchCSSFromGoogleFonts;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","fetchCSSFromGoogleFonts","node_fetch_1","require","next_font_error_1","get_proxy_agent_1","retry","fn","attempts","cnt","err","console","error","message","Promise","resolve","setTimeout","url","fontFamily","isDev","mockedResponse","process","env","NEXT_FONT_GOOGLE_MOCKED_RESPONSES","mockFile","nextFontError","cssResponse","controller","AbortController","undefined","signal","timeoutId","abort","res","default","agent","getProxyAgent","headers","finally","clearTimeout","ok","text"],"sources":["/Users/albertformatger/Documents/GitHub/web_musica/node_modules/next/dist/compiled/@next/font/dist/google/fetch-css-from-google-fonts.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fetchCSSFromGoogleFonts = void 0;\n// @ts-ignore\nconst node_fetch_1 = __importDefault(require(\"next/dist/compiled/node-fetch\"));\nconst next_font_error_1 = require(\"../next-font-error\");\nconst get_proxy_agent_1 = require(\"./get-proxy-agent\");\nasync function retry(fn, attempts) {\n    let cnt = attempts;\n    while (true) {\n        try {\n            return await fn();\n        }\n        catch (err) {\n            cnt--;\n            if (cnt <= 0)\n                throw err;\n            console.error(err.message + `\\n\\nRetrying ${attempts - cnt}/3...`);\n            await new Promise((resolve) => setTimeout(resolve, 100));\n        }\n    }\n}\n/**\n * Fetches the CSS containing the @font-face declarations from Google Fonts.\n * The fetch has a user agent header with a modern browser to ensure we'll get .woff2 files.\n *\n * The env variable NEXT_FONT_GOOGLE_MOCKED_RESPONSES may be set containing a path to mocked data.\n * It's used to define mocked data to avoid hitting the Google Fonts API during tests.\n */\nasync function fetchCSSFromGoogleFonts(url, fontFamily, isDev) {\n    // Check if mocked responses are defined, if so use them instead of fetching from Google Fonts\n    let mockedResponse;\n    if (process.env.NEXT_FONT_GOOGLE_MOCKED_RESPONSES) {\n        const mockFile = require(process.env.NEXT_FONT_GOOGLE_MOCKED_RESPONSES);\n        mockedResponse = mockFile[url];\n        if (!mockedResponse) {\n            (0, next_font_error_1.nextFontError)('Missing mocked response for URL: ' + url);\n        }\n    }\n    let cssResponse;\n    if (mockedResponse) {\n        // Just use the mocked CSS if it's set\n        cssResponse = mockedResponse;\n    }\n    else {\n        // Retry the fetch a few times in case of network issues as some font files\n        // are quite large:\n        // https://github.com/vercel/next.js/issues/45080\n        cssResponse = await retry(async () => {\n            const controller = isDev && typeof AbortController !== 'undefined'\n                ? new AbortController()\n                : undefined;\n            const signal = controller === null || controller === void 0 ? void 0 : controller.signal;\n            const timeoutId = controller\n                ? setTimeout(() => controller.abort(), 3000)\n                : undefined;\n            const res = await (0, node_fetch_1.default)(url, {\n                agent: (0, get_proxy_agent_1.getProxyAgent)(),\n                // Add a timeout in dev\n                signal,\n                headers: {\n                    // The file format is based off of the user agent, make sure woff2 files are fetched\n                    'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36',\n                },\n            }).finally(() => {\n                timeoutId && clearTimeout(timeoutId);\n            });\n            if (!res.ok) {\n                (0, next_font_error_1.nextFontError)(`Failed to fetch font \\`${fontFamily}\\`.\\nURL: ${url}\\n\\nPlease check if the network is available.`);\n            }\n            return res.text();\n        }, 3);\n    }\n    return cssResponse;\n}\nexports.fetchCSSFromGoogleFonts = fetchCSSFromGoogleFonts;\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,eAAe,GAAI,IAAI,IAAI,IAAI,CAACA,eAAe,IAAK,UAAUC,GAAG,EAAE;EACnE,OAAQA,GAAG,IAAIA,GAAG,CAACC,UAAU,GAAID,GAAG,GAAG;IAAE,SAAS,EAAEA;EAAI,CAAC;AAC7D,CAAC;AACDE,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,uBAAuB,GAAG,KAAK,CAAC;AACxC;AACA,MAAMC,YAAY,GAAGR,eAAe,CAACS,OAAO,CAAC,+BAA+B,CAAC,CAAC;AAC9E,MAAMC,iBAAiB,GAAGD,OAAO,CAAC,oBAAoB,CAAC;AACvD,MAAME,iBAAiB,GAAGF,OAAO,CAAC,mBAAmB,CAAC;AACtD,eAAeG,KAAKA,CAACC,EAAE,EAAEC,QAAQ,EAAE;EAC/B,IAAIC,GAAG,GAAGD,QAAQ;EAClB,OAAO,IAAI,EAAE;IACT,IAAI;MACA,OAAO,MAAMD,EAAE,CAAC,CAAC;IACrB,CAAC,CACD,OAAOG,GAAG,EAAE;MACRD,GAAG,EAAE;MACL,IAAIA,GAAG,IAAI,CAAC,EACR,MAAMC,GAAG;MACbC,OAAO,CAACC,KAAK,CAACF,GAAG,CAACG,OAAO,GAAI,gBAAeL,QAAQ,GAAGC,GAAI,OAAM,CAAC;MAClE,MAAM,IAAIK,OAAO,CAAEC,OAAO,IAAKC,UAAU,CAACD,OAAO,EAAE,GAAG,CAAC,CAAC;IAC5D;EACJ;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAed,uBAAuBA,CAACgB,GAAG,EAAEC,UAAU,EAAEC,KAAK,EAAE;EAC3D;EACA,IAAIC,cAAc;EAClB,IAAIC,OAAO,CAACC,GAAG,CAACC,iCAAiC,EAAE;IAC/C,MAAMC,QAAQ,GAAGrB,OAAO,CAACkB,OAAO,CAACC,GAAG,CAACC,iCAAiC,CAAC;IACvEH,cAAc,GAAGI,QAAQ,CAACP,GAAG,CAAC;IAC9B,IAAI,CAACG,cAAc,EAAE;MACjB,CAAC,CAAC,EAAEhB,iBAAiB,CAACqB,aAAa,EAAE,mCAAmC,GAAGR,GAAG,CAAC;IACnF;EACJ;EACA,IAAIS,WAAW;EACf,IAAIN,cAAc,EAAE;IAChB;IACAM,WAAW,GAAGN,cAAc;EAChC,CAAC,MACI;IACD;IACA;IACA;IACAM,WAAW,GAAG,MAAMpB,KAAK,CAAC,YAAY;MAClC,MAAMqB,UAAU,GAAGR,KAAK,IAAI,OAAOS,eAAe,KAAK,WAAW,GAC5D,IAAIA,eAAe,CAAC,CAAC,GACrBC,SAAS;MACf,MAAMC,MAAM,GAAGH,UAAU,KAAK,IAAI,IAAIA,UAAU,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,UAAU,CAACG,MAAM;MACxF,MAAMC,SAAS,GAAGJ,UAAU,GACtBX,UAAU,CAAC,MAAMW,UAAU,CAACK,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,GAC1CH,SAAS;MACf,MAAMI,GAAG,GAAG,MAAM,CAAC,CAAC,EAAE/B,YAAY,CAACgC,OAAO,EAAEjB,GAAG,EAAE;QAC7CkB,KAAK,EAAE,CAAC,CAAC,EAAE9B,iBAAiB,CAAC+B,aAAa,EAAE,CAAC;QAC7C;QACAN,MAAM;QACNO,OAAO,EAAE;UACL;UACA,YAAY,EAAE;QAClB;MACJ,CAAC,CAAC,CAACC,OAAO,CAAC,MAAM;QACbP,SAAS,IAAIQ,YAAY,CAACR,SAAS,CAAC;MACxC,CAAC,CAAC;MACF,IAAI,CAACE,GAAG,CAACO,EAAE,EAAE;QACT,CAAC,CAAC,EAAEpC,iBAAiB,CAACqB,aAAa,EAAG,0BAAyBP,UAAW,aAAYD,GAAI,+CAA8C,CAAC;MAC7I;MACA,OAAOgB,GAAG,CAACQ,IAAI,CAAC,CAAC;IACrB,CAAC,EAAE,CAAC,CAAC;EACT;EACA,OAAOf,WAAW;AACtB;AACA3B,OAAO,CAACE,uBAAuB,GAAGA,uBAAuB"},"metadata":{},"sourceType":"script","externalDependencies":[]}