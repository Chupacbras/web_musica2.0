{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  getTracer: null,\n  SpanStatusCode: null,\n  SpanKind: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  getTracer: function () {\n    return getTracer;\n  },\n  SpanStatusCode: function () {\n    return SpanStatusCode;\n  },\n  SpanKind: function () {\n    return SpanKind;\n  }\n});\nconst _constants = require(\"./constants\");\nlet api;\n// we want to allow users to use their own version of @opentelemetry/api if they\n// want to, so we try to require it first, and if it fails we fall back to the\n// version that is bundled with Next.js\n// this is because @opentelemetry/api has to be synced with the version of\n// @opentelemetry/tracing that is used, and we don't want to force users to use\n// the version that is bundled with Next.js.\n// the API is ~stable, so this should be fine\nif (process.env.NEXT_RUNTIME === \"edge\") {\n  api = require(\"@opentelemetry/api\");\n} else {\n  try {\n    api = require(\"@opentelemetry/api\");\n  } catch (err) {\n    api = require(\"next/dist/compiled/@opentelemetry/api\");\n  }\n}\nconst {\n  context,\n  trace,\n  SpanStatusCode,\n  SpanKind\n} = api;\nconst isPromise = p => {\n  return p !== null && typeof p === \"object\" && typeof p.then === \"function\";\n};\nconst closeSpanWithError = (span, error) => {\n  if (error) {\n    span.recordException(error);\n  }\n  span.setStatus({\n    code: SpanStatusCode.ERROR,\n    message: error == null ? void 0 : error.message\n  });\n  span.end();\n};\n/** we use this map to propagate attributes from nested spans to the top span */\nconst rootSpanAttributesStore = new Map();\nconst rootSpanIdKey = api.createContextKey(\"next.rootSpanId\");\nlet lastSpanId = 0;\nconst getSpanId = () => lastSpanId++;\nclass NextTracerImpl {\n  /**\n  * Returns an instance to the trace with configured name.\n  * Since wrap / trace can be defined in any place prior to actual trace subscriber initialization,\n  * This should be lazily evaluated.\n  */\n  getTracerInstance() {\n    return trace.getTracer(\"next.js\", \"0.0.1\");\n  }\n  getContext() {\n    return context;\n  }\n  getActiveScopeSpan() {\n    return trace.getSpan(context == null ? void 0 : context.active());\n  }\n  trace(...args) {\n    const [type, fnOrOptions, fnOrEmpty] = args;\n    // coerce options form overload\n    const {\n      fn,\n      options\n    } = typeof fnOrOptions === \"function\" ? {\n      fn: fnOrOptions,\n      options: {}\n    } : {\n      fn: fnOrEmpty,\n      options: {\n        ...fnOrOptions\n      }\n    };\n    if (!_constants.NextVanillaSpanAllowlist.includes(type) && process.env.NEXT_OTEL_VERBOSE !== \"1\" || options.hideSpan) {\n      return fn();\n    }\n    const spanName = options.spanName ?? type;\n    // Trying to get active scoped span to assign parent. If option specifies parent span manually, will try to use it.\n    let spanContext = this.getSpanContext((options == null ? void 0 : options.parentSpan) ?? this.getActiveScopeSpan());\n    let isRootSpan = false;\n    if (!spanContext) {\n      spanContext = api.ROOT_CONTEXT;\n      isRootSpan = true;\n    }\n    const spanId = getSpanId();\n    options.attributes = {\n      \"next.span_name\": spanName,\n      \"next.span_type\": type,\n      ...options.attributes\n    };\n    return api.context.with(spanContext.setValue(rootSpanIdKey, spanId), () => this.getTracerInstance().startActiveSpan(spanName, options, span => {\n      const onCleanup = () => {\n        rootSpanAttributesStore.delete(spanId);\n      };\n      if (isRootSpan) {\n        rootSpanAttributesStore.set(spanId, new Map(Object.entries(options.attributes ?? {})));\n      }\n      try {\n        if (fn.length > 1) {\n          return fn(span, err => closeSpanWithError(span, err));\n        }\n        const result = fn(span);\n        if (isPromise(result)) {\n          result.then(() => span.end(), err => closeSpanWithError(span, err)).finally(onCleanup);\n        } else {\n          span.end();\n          onCleanup();\n        }\n        return result;\n      } catch (err) {\n        closeSpanWithError(span, err);\n        onCleanup();\n        throw err;\n      }\n    }));\n  }\n  wrap(...args) {\n    const tracer = this;\n    const [name, options, fn] = args.length === 3 ? args : [args[0], {}, args[1]];\n    if (!_constants.NextVanillaSpanAllowlist.includes(name) && process.env.NEXT_OTEL_VERBOSE !== \"1\") {\n      return fn;\n    }\n    return function () {\n      let optionsObj = options;\n      if (typeof optionsObj === \"function\" && typeof fn === \"function\") {\n        optionsObj = optionsObj.apply(this, arguments);\n      }\n      const lastArgId = arguments.length - 1;\n      const cb = arguments[lastArgId];\n      if (typeof cb === \"function\") {\n        const scopeBoundCb = tracer.getContext().bind(context.active(), cb);\n        return tracer.trace(name, optionsObj, (_span, done) => {\n          arguments[lastArgId] = function (err) {\n            done == null ? void 0 : done(err);\n            return scopeBoundCb.apply(this, arguments);\n          };\n          return fn.apply(this, arguments);\n        });\n      } else {\n        return tracer.trace(name, optionsObj, () => fn.apply(this, arguments));\n      }\n    };\n  }\n  startSpan(...args) {\n    const [type, options] = args;\n    const spanContext = this.getSpanContext((options == null ? void 0 : options.parentSpan) ?? this.getActiveScopeSpan());\n    return this.getTracerInstance().startSpan(type, options, spanContext);\n  }\n  getSpanContext(parentSpan) {\n    const spanContext = parentSpan ? trace.setSpan(context.active(), parentSpan) : undefined;\n    return spanContext;\n  }\n  getRootSpanAttributes() {\n    const spanId = context.active().getValue(rootSpanIdKey);\n    return rootSpanAttributesStore.get(spanId);\n  }\n}\nconst getTracer = (() => {\n  const tracer = new NextTracerImpl();\n  return () => tracer;\n})();","map":{"version":3,"names":["getTracer","SpanStatusCode","SpanKind","api","process","env","NEXT_RUNTIME","require","err","context","trace","isPromise","p","then","closeSpanWithError","span","error","recordException","setStatus","code","ERROR","message","end","rootSpanAttributesStore","Map","rootSpanIdKey","createContextKey","lastSpanId","getSpanId","NextTracerImpl","getTracerInstance","getContext","getActiveScopeSpan","getSpan","active","args","type","fnOrOptions","fnOrEmpty","fn","options","_constants","NextVanillaSpanAllowlist","includes","NEXT_OTEL_VERBOSE","hideSpan","spanName","spanContext","getSpanContext","parentSpan","isRootSpan","ROOT_CONTEXT","spanId","attributes","with","setValue","startActiveSpan","onCleanup","delete","set","Object","entries","length","result","finally","wrap","tracer","name","optionsObj","apply","arguments","lastArgId","cb","scopeBoundCb","bind","_span","done","startSpan","setSpan","undefined","getRootSpanAttributes","getValue","get"],"sources":["../../../../src/server/lib/trace/tracer.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}