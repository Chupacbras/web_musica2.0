{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  CacheHandler: null,\n  IncrementalCache: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  CacheHandler: function () {\n    return CacheHandler;\n  },\n  IncrementalCache: function () {\n    return IncrementalCache;\n  }\n});\nconst _fetchcache = /*#__PURE__*/_interop_require_default(require(\"./fetch-cache\"));\nconst _filesystemcache = /*#__PURE__*/_interop_require_default(require(\"./file-system-cache\"));\nconst _path = /*#__PURE__*/_interop_require_default(require(\"../../../shared/lib/isomorphic/path\"));\nconst _encodedecode = require(\"../../stream-utils/encode-decode\");\nconst _base64arraybuffer = require(\"../../../shared/lib/base64-arraybuffer\");\nconst _normalizepagepath = require(\"../../../shared/lib/page-path/normalize-page-path\");\nconst _constants = require(\"../../../lib/constants\");\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction toRoute(pathname) {\n  return pathname.replace(/\\/$/, \"\").replace(/\\/index$/, \"\") || \"/\";\n}\nclass CacheHandler {\n  // eslint-disable-next-line\n  constructor(_ctx) {}\n  async get(..._args) {\n    return {};\n  }\n  async set(..._args) {}\n  async revalidateTag(_tag) {}\n}\nclass IncrementalCache {\n  constructor({\n    fs,\n    dev,\n    appDir,\n    flushToDisk,\n    fetchCache,\n    minimalMode,\n    serverDistDir,\n    requestHeaders,\n    requestProtocol,\n    maxMemoryCacheSize,\n    getPrerenderManifest,\n    fetchCacheKeyPrefix,\n    CurCacheHandler,\n    allowedRevalidateHeaderKeys\n  }) {\n    var _this_prerenderManifest_preview, _this_prerenderManifest, _this_prerenderManifest_preview1, _this_prerenderManifest1;\n    this.locks = new Map();\n    this.unlocks = new Map();\n    const debug = !!process.env.NEXT_PRIVATE_DEBUG_CACHE;\n    if (!CurCacheHandler) {\n      if (fs && serverDistDir) {\n        if (debug) {\n          console.log(\"using filesystem cache handler\");\n        }\n        CurCacheHandler = _filesystemcache.default;\n      }\n      if (_fetchcache.default.isAvailable({\n        _requestHeaders: requestHeaders\n      }) && minimalMode && fetchCache) {\n        if (debug) {\n          console.log(\"using fetch cache handler\");\n        }\n        CurCacheHandler = _fetchcache.default;\n      }\n    } else if (debug) {\n      console.log(\"using custom cache handler\", CurCacheHandler.name);\n    }\n    if (process.env.__NEXT_TEST_MAX_ISR_CACHE) {\n      // Allow cache size to be overridden for testing purposes\n      maxMemoryCacheSize = parseInt(process.env.__NEXT_TEST_MAX_ISR_CACHE, 10);\n    }\n    this.dev = dev;\n    // this is a hack to avoid Webpack knowing this is equal to this.minimalMode\n    // because we replace this.minimalMode to true in production bundles.\n    const minimalModeKey = \"minimalMode\";\n    this[minimalModeKey] = minimalMode;\n    this.requestHeaders = requestHeaders;\n    this.requestProtocol = requestProtocol;\n    this.allowedRevalidateHeaderKeys = allowedRevalidateHeaderKeys;\n    this.prerenderManifest = getPrerenderManifest();\n    this.fetchCacheKeyPrefix = fetchCacheKeyPrefix;\n    let revalidatedTags = [];\n    if (requestHeaders[_constants.PRERENDER_REVALIDATE_HEADER] === ((_this_prerenderManifest = this.prerenderManifest) == null ? void 0 : (_this_prerenderManifest_preview = _this_prerenderManifest.preview) == null ? void 0 : _this_prerenderManifest_preview.previewModeId)) {\n      this.isOnDemandRevalidate = true;\n    }\n    if (minimalMode && typeof requestHeaders[_constants.NEXT_CACHE_REVALIDATED_TAGS_HEADER] === \"string\" && requestHeaders[_constants.NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER] === ((_this_prerenderManifest1 = this.prerenderManifest) == null ? void 0 : (_this_prerenderManifest_preview1 = _this_prerenderManifest1.preview) == null ? void 0 : _this_prerenderManifest_preview1.previewModeId)) {\n      revalidatedTags = requestHeaders[_constants.NEXT_CACHE_REVALIDATED_TAGS_HEADER].split(\",\");\n    }\n    if (CurCacheHandler) {\n      this.cacheHandler = new CurCacheHandler({\n        dev,\n        fs,\n        flushToDisk,\n        serverDistDir,\n        revalidatedTags,\n        maxMemoryCacheSize,\n        _appDir: !!appDir,\n        _requestHeaders: requestHeaders,\n        fetchCacheKeyPrefix\n      });\n    }\n  }\n  calculateRevalidate(pathname, fromTime, dev) {\n    // in development we don't have a prerender-manifest\n    // and default to always revalidating to allow easier debugging\n    if (dev) return new Date().getTime() - 1000;\n    // if an entry isn't present in routes we fallback to a default\n    // of revalidating after 1 second\n    const {\n      initialRevalidateSeconds\n    } = this.prerenderManifest.routes[toRoute(pathname)] || {\n      initialRevalidateSeconds: 1\n    };\n    const revalidateAfter = typeof initialRevalidateSeconds === \"number\" ? initialRevalidateSeconds * 1000 + fromTime : initialRevalidateSeconds;\n    return revalidateAfter;\n  }\n  _getPathname(pathname, fetchCache) {\n    return fetchCache ? pathname : (0, _normalizepagepath.normalizePagePath)(pathname);\n  }\n  async unlock(cacheKey) {\n    const unlock = this.unlocks.get(cacheKey);\n    if (unlock) {\n      unlock();\n      this.locks.delete(cacheKey);\n      this.unlocks.delete(cacheKey);\n    }\n  }\n  async lock(cacheKey) {\n    if (process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT && process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY && process.env.NEXT_RUNTIME !== \"edge\") {\n      const invokeIpcMethod = require(\"../server-ipc/request-utils\").invokeIpcMethod;\n      await invokeIpcMethod({\n        method: \"lock\",\n        ipcPort: process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT,\n        ipcKey: process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY,\n        args: [cacheKey]\n      });\n      return async () => {\n        await invokeIpcMethod({\n          method: \"unlock\",\n          ipcPort: process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT,\n          ipcKey: process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY,\n          args: [cacheKey]\n        });\n      };\n    }\n    let unlockNext = () => Promise.resolve();\n    const existingLock = this.locks.get(cacheKey);\n    if (existingLock) {\n      await existingLock;\n    } else {\n      const newLock = new Promise(resolve => {\n        unlockNext = async () => {\n          resolve();\n        };\n      });\n      this.locks.set(cacheKey, newLock);\n      this.unlocks.set(cacheKey, unlockNext);\n    }\n    return unlockNext;\n  }\n  async revalidateTag(tag) {\n    var _this_cacheHandler_revalidateTag, _this_cacheHandler;\n    if (process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT && process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY && process.env.NEXT_RUNTIME !== \"edge\") {\n      const invokeIpcMethod = require(\"../server-ipc/request-utils\").invokeIpcMethod;\n      return invokeIpcMethod({\n        method: \"revalidateTag\",\n        ipcPort: process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT,\n        ipcKey: process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY,\n        args: [...arguments]\n      });\n    }\n    return (_this_cacheHandler = this.cacheHandler) == null ? void 0 : (_this_cacheHandler_revalidateTag = _this_cacheHandler.revalidateTag) == null ? void 0 : _this_cacheHandler_revalidateTag.call(_this_cacheHandler, tag);\n  }\n  // x-ref: https://github.com/facebook/react/blob/2655c9354d8e1c54ba888444220f63e836925caa/packages/react/src/ReactFetch.js#L23\n  async fetchCacheKey(url, init = {}) {\n    // this should be bumped anytime a fix is made to cache entries\n    // that should bust the cache\n    const MAIN_KEY_PREFIX = \"v3\";\n    let cacheKey;\n    const bodyChunks = [];\n    if (init.body) {\n      // handle ReadableStream body\n      if (typeof init.body.getReader === \"function\") {\n        const readableBody = init.body;\n        const reader = readableBody.getReader();\n        let arrayBuffer = new Uint8Array();\n        function processValue({\n          done,\n          value\n        }) {\n          if (done) {\n            return;\n          }\n          if (value) {\n            try {\n              bodyChunks.push(typeof value === \"string\" ? value : (0, _base64arraybuffer.encode)(value));\n              const curBuffer = typeof value === \"string\" ? (0, _encodedecode.encodeText)(value) : new Uint8Array(value);\n              const prevBuffer = arrayBuffer;\n              arrayBuffer = new Uint8Array(prevBuffer.byteLength + curBuffer.byteLength);\n              arrayBuffer.set(prevBuffer);\n              arrayBuffer.set(curBuffer, prevBuffer.byteLength);\n            } catch (err) {\n              console.error(err);\n            }\n          }\n          reader.read().then(processValue);\n        }\n        await reader.read().then(processValue);\n        init._ogBody = arrayBuffer;\n      } else if (typeof init.body.keys === \"function\") {\n        const formData = init.body;\n        init._ogBody = init.body;\n        for (const key of new Set([...formData.keys()])) {\n          const values = formData.getAll(key);\n          bodyChunks.push(`${key}=${(await Promise.all(values.map(async val => {\n            if (typeof val === \"string\") {\n              return val;\n            } else {\n              return await val.text();\n            }\n          }))).join(\",\")}`);\n        }\n        // handle blob body\n      } else if (typeof init.body.arrayBuffer === \"function\") {\n        const blob = init.body;\n        const arrayBuffer = await blob.arrayBuffer();\n        bodyChunks.push((0, _base64arraybuffer.encode)(await init.body.arrayBuffer()));\n        init._ogBody = new Blob([arrayBuffer], {\n          type: blob.type\n        });\n      } else if (typeof init.body === \"string\") {\n        bodyChunks.push(init.body);\n        init._ogBody = init.body;\n      }\n    }\n    const cacheString = JSON.stringify([MAIN_KEY_PREFIX, this.fetchCacheKeyPrefix || \"\", url, init.method, typeof (init.headers || {}).keys === \"function\" ? Object.fromEntries(init.headers) : init.headers, init.mode, init.redirect, init.credentials, init.referrer, init.referrerPolicy, init.integrity, init.cache, bodyChunks]);\n    if (process.env.NEXT_RUNTIME === \"edge\") {\n      function bufferToHex(buffer) {\n        return Array.prototype.map.call(new Uint8Array(buffer), b => b.toString(16).padStart(2, \"0\")).join(\"\");\n      }\n      const buffer = (0, _encodedecode.encodeText)(cacheString);\n      cacheKey = bufferToHex(await crypto.subtle.digest(\"SHA-256\", buffer));\n    } else {\n      const crypto1 = require(\"crypto\");\n      cacheKey = crypto1.createHash(\"sha256\").update(cacheString).digest(\"hex\");\n    }\n    return cacheKey;\n  }\n  // get data from cache if available\n  async get(cacheKey, ctx = {}) {\n    var _this_cacheHandler, _cacheData_value, _this_prerenderManifest_routes_toRoute;\n    if (process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT && process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY && process.env.NEXT_RUNTIME !== \"edge\") {\n      const invokeIpcMethod = require(\"../server-ipc/request-utils\").invokeIpcMethod;\n      return invokeIpcMethod({\n        method: \"get\",\n        ipcPort: process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT,\n        ipcKey: process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY,\n        args: [...arguments]\n      });\n    }\n    // we don't leverage the prerender cache in dev mode\n    // so that getStaticProps is always called for easier debugging\n    if (this.dev && (!ctx.fetchCache || this.requestHeaders[\"cache-control\"] === \"no-cache\")) {\n      return null;\n    }\n    cacheKey = this._getPathname(cacheKey, ctx.fetchCache);\n    let entry = null;\n    let revalidate = ctx.revalidate;\n    const cacheData = await ((_this_cacheHandler = this.cacheHandler) == null ? void 0 : _this_cacheHandler.get(cacheKey, ctx));\n    if ((cacheData == null ? void 0 : (_cacheData_value = cacheData.value) == null ? void 0 : _cacheData_value.kind) === \"FETCH\") {\n      const combinedTags = [...(ctx.tags || []), ...(ctx.softTags || [])];\n      // if a tag was revalidated we don't return stale data\n      if (combinedTags.some(tag => {\n        var _this_revalidatedTags;\n        return (_this_revalidatedTags = this.revalidatedTags) == null ? void 0 : _this_revalidatedTags.includes(tag);\n      })) {\n        return null;\n      }\n      revalidate = revalidate || cacheData.value.revalidate;\n      const age = Math.round((Date.now() - (cacheData.lastModified || 0)) / 1000);\n      const isStale = age > revalidate;\n      const data = cacheData.value.data;\n      return {\n        isStale: isStale,\n        value: {\n          kind: \"FETCH\",\n          data,\n          revalidate: revalidate\n        },\n        revalidateAfter: Date.now() + revalidate * 1000\n      };\n    }\n    const curRevalidate = (_this_prerenderManifest_routes_toRoute = this.prerenderManifest.routes[toRoute(cacheKey)]) == null ? void 0 : _this_prerenderManifest_routes_toRoute.initialRevalidateSeconds;\n    let isStale;\n    let revalidateAfter;\n    if ((cacheData == null ? void 0 : cacheData.lastModified) === -1) {\n      isStale = -1;\n      revalidateAfter = -1 * _constants.CACHE_ONE_YEAR;\n    } else {\n      revalidateAfter = this.calculateRevalidate(cacheKey, (cacheData == null ? void 0 : cacheData.lastModified) || Date.now(), this.dev && !ctx.fetchCache);\n      isStale = revalidateAfter !== false && revalidateAfter < Date.now() ? true : undefined;\n    }\n    if (cacheData) {\n      entry = {\n        isStale,\n        curRevalidate,\n        revalidateAfter,\n        value: cacheData.value\n      };\n    }\n    if (!cacheData && this.prerenderManifest.notFoundRoutes.includes(cacheKey)) {\n      // for the first hit after starting the server the cache\n      // may not have a way to save notFound: true so if\n      // the prerender-manifest marks this as notFound then we\n      // return that entry and trigger a cache set to give it a\n      // chance to update in-memory entries\n      entry = {\n        isStale,\n        value: null,\n        curRevalidate,\n        revalidateAfter\n      };\n      this.set(cacheKey, entry.value, ctx);\n    }\n    return entry;\n  }\n  // populate the incremental cache with new data\n  async set(pathname, data, ctx) {\n    if (process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT && process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY && process.env.NEXT_RUNTIME !== \"edge\") {\n      const invokeIpcMethod = require(\"../server-ipc/request-utils\").invokeIpcMethod;\n      return invokeIpcMethod({\n        method: \"set\",\n        ipcPort: process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT,\n        ipcKey: process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY,\n        args: [...arguments]\n      });\n    }\n    if (this.dev && !ctx.fetchCache) return;\n    // fetchCache has upper limit of 2MB per-entry currently\n    if (ctx.fetchCache && JSON.stringify(data).length > 2 * 1024 * 1024) {\n      if (this.dev) {\n        throw new Error(`fetch for over 2MB of data can not be cached`);\n      }\n      return;\n    }\n    pathname = this._getPathname(pathname, ctx.fetchCache);\n    try {\n      var _this_cacheHandler;\n      // we use the prerender manifest memory instance\n      // to store revalidate timings for calculating\n      // revalidateAfter values so we update this on set\n      if (typeof ctx.revalidate !== \"undefined\" && !ctx.fetchCache) {\n        this.prerenderManifest.routes[pathname] = {\n          dataRoute: _path.default.posix.join(\"/_next/data\", `${(0, _normalizepagepath.normalizePagePath)(pathname)}.json`),\n          srcRoute: null,\n          initialRevalidateSeconds: ctx.revalidate\n        };\n      }\n      await ((_this_cacheHandler = this.cacheHandler) == null ? void 0 : _this_cacheHandler.set(pathname, data, ctx));\n    } catch (error) {\n      console.warn(\"Failed to update prerender cache for\", pathname, error);\n    }\n  }\n}","map":{"version":3,"names":["CacheHandler","IncrementalCache","toRoute","pathname","replace","constructor","_ctx","get","_args","set","revalidateTag","_tag","fs","dev","appDir","flushToDisk","fetchCache","minimalMode","serverDistDir","requestHeaders","requestProtocol","maxMemoryCacheSize","getPrerenderManifest","fetchCacheKeyPrefix","CurCacheHandler","allowedRevalidateHeaderKeys","_this_prerenderManifest_preview","_this_prerenderManifest","_this_prerenderManifest_preview1","_this_prerenderManifest1","locks","Map","unlocks","debug","process","env","NEXT_PRIVATE_DEBUG_CACHE","console","log","_filesystemcache","default","_fetchcache","isAvailable","_requestHeaders","name","__NEXT_TEST_MAX_ISR_CACHE","parseInt","minimalModeKey","prerenderManifest","revalidatedTags","_constants","PRERENDER_REVALIDATE_HEADER","preview","previewModeId","isOnDemandRevalidate","NEXT_CACHE_REVALIDATED_TAGS_HEADER","NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER","split","cacheHandler","_appDir","calculateRevalidate","fromTime","Date","getTime","initialRevalidateSeconds","routes","revalidateAfter","_getPathname","_normalizepagepath","normalizePagePath","unlock","cacheKey","delete","lock","__NEXT_INCREMENTAL_CACHE_IPC_PORT","__NEXT_INCREMENTAL_CACHE_IPC_KEY","NEXT_RUNTIME","invokeIpcMethod","require","method","ipcPort","ipcKey","args","unlockNext","Promise","resolve","existingLock","newLock","tag","_this_cacheHandler_revalidateTag","_this_cacheHandler","arguments","call","fetchCacheKey","url","init","MAIN_KEY_PREFIX","bodyChunks","body","getReader","readableBody","reader","arrayBuffer","Uint8Array","processValue","done","value","push","_base64arraybuffer","encode","curBuffer","_encodedecode","encodeText","prevBuffer","byteLength","err","error","read","then","_ogBody","keys","formData","key","Set","values","getAll","all","map","val","text","join","blob","Blob","type","cacheString","JSON","stringify","headers","Object","fromEntries","mode","redirect","credentials","referrer","referrerPolicy","integrity","cache","bufferToHex","buffer","Array","prototype","b","toString","padStart","crypto","subtle","digest","crypto1","createHash","update","ctx","_cacheData_value","_this_prerenderManifest_routes_toRoute","entry","revalidate","cacheData","kind","combinedTags","tags","softTags","some","_this_revalidatedTags","includes","age","Math","round","now","lastModified","isStale","data","curRevalidate","CACHE_ONE_YEAR","undefined","notFoundRoutes","length","Error","dataRoute","_path","posix","srcRoute","warn"],"sources":["../../../../src/server/lib/incremental-cache/index.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}