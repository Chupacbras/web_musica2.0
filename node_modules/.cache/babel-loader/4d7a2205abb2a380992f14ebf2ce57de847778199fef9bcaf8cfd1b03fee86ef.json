{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"recursiveCopy\", {\n  enumerable: true,\n  get: function () {\n    return recursiveCopy;\n  }\n});\nconst _path = /*#__PURE__*/_interop_require_default(require(\"path\"));\nconst _fs = require(\"fs\");\nconst _asyncsema = require(\"next/dist/compiled/async-sema\");\nconst _iserror = /*#__PURE__*/_interop_require_default(require(\"./is-error\"));\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nconst COPYFILE_EXCL = _fs.constants.COPYFILE_EXCL;\nasync function recursiveCopy(source, dest, {\n  concurrency = 32,\n  overwrite = false,\n  filter = () => true\n} = {}) {\n  const cwdPath = process.cwd();\n  const from = _path.default.resolve(cwdPath, source);\n  const to = _path.default.resolve(cwdPath, dest);\n  const sema = new _asyncsema.Sema(concurrency);\n  // deep copy the file/directory\n  async function _copy(item, lstats) {\n    const target = item.replace(from, to);\n    await sema.acquire();\n    if (!lstats) {\n      // after lock on first run\n      lstats = await _fs.promises.lstat(from);\n    }\n    // readdir & lstat do not follow symbolic links\n    // if part is a symbolic link, follow it with stat\n    let isFile = lstats.isFile();\n    let isDirectory = lstats.isDirectory();\n    if (lstats.isSymbolicLink()) {\n      const stats = await _fs.promises.stat(item);\n      isFile = stats.isFile();\n      isDirectory = stats.isDirectory();\n    }\n    if (isDirectory) {\n      try {\n        await _fs.promises.mkdir(target, {\n          recursive: true\n        });\n      } catch (err) {\n        // do not throw `folder already exists` errors\n        if ((0, _iserror.default)(err) && err.code !== \"EEXIST\") {\n          throw err;\n        }\n      }\n      sema.release();\n      const files = await _fs.promises.readdir(item, {\n        withFileTypes: true\n      });\n      await Promise.all(files.map(file => _copy(_path.default.join(item, file.name), file)));\n    } else if (isFile &&\n    // before we send the path to filter\n    // we remove the base path (from) and replace \\ by / (windows)\n    filter(item.replace(from, \"\").replace(/\\\\/g, \"/\"))) {\n      await _fs.promises.copyFile(item, target, overwrite ? undefined : COPYFILE_EXCL);\n      sema.release();\n    } else {\n      sema.release();\n    }\n  }\n  await _copy(from);\n}","map":{"version":3,"names":["recursiveCopy","COPYFILE_EXCL","_fs","constants","source","dest","concurrency","overwrite","filter","cwdPath","process","cwd","from","_path","default","resolve","to","sema","_asyncsema","Sema","_copy","item","lstats","target","replace","acquire","promises","lstat","isFile","isDirectory","isSymbolicLink","stats","stat","mkdir","recursive","err","_iserror","code","release","files","readdir","withFileTypes","Promise","all","map","file","join","name","copyFile","undefined"],"sources":["../../src/lib/recursive-copy.ts"],"sourcesContent":[null],"mappings":";;;;;+BAOsB;;;WAAAA,aAAA;;;4DAPL;oBACkC;2BAC9B;+DACD;;;;;;AAEpB,MAAMC,aAAA,GAAgBC,GAAA,CAAAC,SAAS,CAACF,aAAa;AAEtC,eAAeD,cACpBI,MAAc,EACdC,IAAY,EACZ;EACEC,WAAA,GAAc,EAAE;EAChBC,SAAA,GAAY,KAAK;EACjBC,MAAA,GAASA,CAAA,KAAM;AAAI,CAKpB,GAAG,CAAC,CAAC;EAEN,MAAMC,OAAA,GAAUC,OAAA,CAAQC,GAAG;EAC3B,MAAMC,IAAA,GAAOC,KAAA,CAAAC,OAAI,CAACC,OAAO,CAACN,OAAA,EAASL,MAAA;EACnC,MAAMY,EAAA,GAAKH,KAAA,CAAAC,OAAI,CAACC,OAAO,CAACN,OAAA,EAASJ,IAAA;EAEjC,MAAMY,IAAA,GAAO,IAAIC,UAAA,CAAAC,IAAI,CAACb,WAAA;EAEtB;EACA,eAAec,MAAMC,IAAY,EAAEC,MAAuB;IACxD,MAAMC,MAAA,GAASF,IAAA,CAAKG,OAAO,CAACZ,IAAA,EAAMI,EAAA;IAElC,MAAMC,IAAA,CAAKQ,OAAO;IAElB,IAAI,CAACH,MAAA,EAAQ;MACX;MACAA,MAAA,GAAS,MAAMpB,GAAA,CAAAwB,QAAQ,CAACC,KAAK,CAACf,IAAA;IAChC;IAEA;IACA;IACA,IAAIgB,MAAA,GAASN,MAAA,CAAOM,MAAM;IAC1B,IAAIC,WAAA,GAAcP,MAAA,CAAOO,WAAW;IACpC,IAAIP,MAAA,CAAOQ,cAAc,IAAI;MAC3B,MAAMC,KAAA,GAAQ,MAAM7B,GAAA,CAAAwB,QAAQ,CAACM,IAAI,CAACX,IAAA;MAClCO,MAAA,GAASG,KAAA,CAAMH,MAAM;MACrBC,WAAA,GAAcE,KAAA,CAAMF,WAAW;IACjC;IAEA,IAAIA,WAAA,EAAa;MACf,IAAI;QACF,MAAM3B,GAAA,CAAAwB,QAAQ,CAACO,KAAK,CAACV,MAAA,EAAQ;UAAEW,SAAA,EAAW;QAAK;MACjD,EAAE,OAAOC,GAAA,EAAK;QACZ;QACA,IAAI,IAAAC,QAAA,CAAAtB,OAAO,EAACqB,GAAA,KAAQA,GAAA,CAAIE,IAAI,KAAK,UAAU;UACzC,MAAMF,GAAA;QACR;MACF;MACAlB,IAAA,CAAKqB,OAAO;MACZ,MAAMC,KAAA,GAAQ,MAAMrC,GAAA,CAAAwB,QAAQ,CAACc,OAAO,CAACnB,IAAA,EAAM;QAAEoB,aAAA,EAAe;MAAK;MACjE,MAAMC,OAAA,CAAQC,GAAG,CACfJ,KAAA,CAAMK,GAAG,CAAEC,IAAA,IAASzB,KAAA,CAAMP,KAAA,CAAAC,OAAI,CAACgC,IAAI,CAACzB,IAAA,EAAMwB,IAAA,CAAKE,IAAI,GAAGF,IAAA;IAE1D,OAAO,IACLjB,MAAA;IACA;IACA;IACApB,MAAA,CAAOa,IAAA,CAAKG,OAAO,CAACZ,IAAA,EAAM,IAAIY,OAAO,CAAC,OAAO,OAC7C;MACA,MAAMtB,GAAA,CAAAwB,QAAQ,CAACsB,QAAQ,CACrB3B,IAAA,EACAE,MAAA,EACAhB,SAAA,GAAY0C,SAAA,GAAYhD,aAAA;MAE1BgB,IAAA,CAAKqB,OAAO;IACd,OAAO;MACLrB,IAAA,CAAKqB,OAAO;IACd;EACF;EAEA,MAAMlB,KAAA,CAAMR,IAAA;AACd"},"metadata":{},"sourceType":"script","externalDependencies":[]}