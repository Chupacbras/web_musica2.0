{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  streamToBufferedResult: null,\n  cloneTransformStream: null,\n  chainStreams: null,\n  streamFromString: null,\n  streamToString: null,\n  createBufferedTransformStream: null,\n  createInsertedHTMLStream: null,\n  renderToInitialStream: null,\n  createInlineDataStream: null,\n  createRootLayoutValidatorStream: null,\n  continueFromInitialStream: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  streamToBufferedResult: function () {\n    return streamToBufferedResult;\n  },\n  cloneTransformStream: function () {\n    return cloneTransformStream;\n  },\n  chainStreams: function () {\n    return chainStreams;\n  },\n  streamFromString: function () {\n    return streamFromString;\n  },\n  streamToString: function () {\n    return streamToString;\n  },\n  createBufferedTransformStream: function () {\n    return createBufferedTransformStream;\n  },\n  createInsertedHTMLStream: function () {\n    return createInsertedHTMLStream;\n  },\n  renderToInitialStream: function () {\n    return renderToInitialStream;\n  },\n  createInlineDataStream: function () {\n    return createInlineDataStream;\n  },\n  createRootLayoutValidatorStream: function () {\n    return createRootLayoutValidatorStream;\n  },\n  continueFromInitialStream: function () {\n    return continueFromInitialStream;\n  }\n});\nconst _nonnullable = require(\"../../lib/non-nullable\");\nconst _tracer = require(\"../lib/trace/tracer\");\nconst _constants = require(\"../lib/trace/constants\");\nconst _encodedecode = require(\"./encode-decode\");\nconst queueTask = process.env.NEXT_RUNTIME === \"edge\" ? globalThis.setTimeout : setImmediate;\nconst streamToBufferedResult = async renderResult => {\n  const renderChunks = [];\n  const textDecoder = new TextDecoder();\n  const writable = {\n    write(chunk) {\n      renderChunks.push((0, _encodedecode.decodeText)(chunk, textDecoder));\n    },\n    end() {},\n    // We do not support stream cancellation\n    on() {},\n    off() {}\n  };\n  await renderResult.pipe(writable);\n  return renderChunks.join(\"\");\n};\nfunction cloneTransformStream(source) {\n  const sourceReader = source.readable.getReader();\n  const clone = new TransformStream({\n    async start(controller) {\n      while (true) {\n        const {\n          done,\n          value\n        } = await sourceReader.read();\n        if (done) {\n          break;\n        }\n        controller.enqueue(value);\n      }\n    },\n    // skip all piped chunks\n    transform() {}\n  });\n  return clone;\n}\nfunction chainStreams(streams) {\n  const {\n    readable,\n    writable\n  } = new TransformStream();\n  let promise = Promise.resolve();\n  for (let i = 0; i < streams.length; ++i) {\n    promise = promise.then(() => streams[i].pipeTo(writable, {\n      preventClose: i + 1 < streams.length\n    }));\n  }\n  return readable;\n}\nfunction streamFromString(str) {\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue((0, _encodedecode.encodeText)(str));\n      controller.close();\n    }\n  });\n}\nasync function streamToString(stream) {\n  const reader = stream.getReader();\n  const textDecoder = new TextDecoder();\n  let bufferedString = \"\";\n  while (true) {\n    const {\n      done,\n      value\n    } = await reader.read();\n    if (done) {\n      return bufferedString;\n    }\n    bufferedString += (0, _encodedecode.decodeText)(value, textDecoder);\n  }\n}\nfunction createBufferedTransformStream() {\n  let bufferedBytes = new Uint8Array();\n  let pendingFlush = null;\n  const flushBuffer = controller => {\n    if (!pendingFlush) {\n      pendingFlush = new Promise(resolve => {\n        queueTask(() => {\n          controller.enqueue(bufferedBytes);\n          bufferedBytes = new Uint8Array();\n          pendingFlush = null;\n          resolve();\n        });\n      });\n    }\n  };\n  return new TransformStream({\n    transform(chunk, controller) {\n      const newBufferedBytes = new Uint8Array(bufferedBytes.length + chunk.byteLength);\n      newBufferedBytes.set(bufferedBytes);\n      newBufferedBytes.set(chunk, bufferedBytes.length);\n      bufferedBytes = newBufferedBytes;\n      flushBuffer(controller);\n    },\n    flush() {\n      if (pendingFlush) {\n        return pendingFlush;\n      }\n    }\n  });\n}\nfunction createInsertedHTMLStream(getServerInsertedHTML) {\n  return new TransformStream({\n    async transform(chunk, controller) {\n      const insertedHTMLChunk = (0, _encodedecode.encodeText)(await getServerInsertedHTML());\n      controller.enqueue(insertedHTMLChunk);\n      controller.enqueue(chunk);\n    }\n  });\n}\nfunction renderToInitialStream({\n  ReactDOMServer,\n  element,\n  streamOptions\n}) {\n  return (0, _tracer.getTracer)().trace(_constants.AppRenderSpan.renderToReadableStream, async () => ReactDOMServer.renderToReadableStream(element, streamOptions));\n}\nfunction createHeadInsertionTransformStream(insert) {\n  let inserted = false;\n  let freezing = false;\n  const textDecoder = new TextDecoder();\n  return new TransformStream({\n    async transform(chunk, controller) {\n      // While react is flushing chunks, we don't apply insertions\n      if (freezing) {\n        controller.enqueue(chunk);\n        return;\n      }\n      const insertion = await insert();\n      if (inserted) {\n        controller.enqueue((0, _encodedecode.encodeText)(insertion));\n        controller.enqueue(chunk);\n        freezing = true;\n      } else {\n        const content = (0, _encodedecode.decodeText)(chunk, textDecoder);\n        const index = content.indexOf(\"</head>\");\n        if (index !== -1) {\n          const insertedHeadContent = content.slice(0, index) + insertion + content.slice(index);\n          controller.enqueue((0, _encodedecode.encodeText)(insertedHeadContent));\n          freezing = true;\n          inserted = true;\n        }\n      }\n      if (!inserted) {\n        controller.enqueue(chunk);\n      } else {\n        queueTask(() => {\n          freezing = false;\n        });\n      }\n    },\n    async flush(controller) {\n      // Check before closing if there's anything remaining to insert.\n      const insertion = await insert();\n      if (insertion) {\n        controller.enqueue((0, _encodedecode.encodeText)(insertion));\n      }\n    }\n  });\n}\n// Suffix after main body content - scripts before </body>,\n// but wait for the major chunks to be enqueued.\nfunction createDeferredSuffixStream(suffix) {\n  let suffixFlushed = false;\n  let suffixFlushTask = null;\n  return new TransformStream({\n    transform(chunk, controller) {\n      controller.enqueue(chunk);\n      if (!suffixFlushed && suffix.length) {\n        suffixFlushed = true;\n        suffixFlushTask = new Promise(res => {\n          // NOTE: streaming flush\n          // Enqueue suffix part before the major chunks are enqueued so that\n          // suffix won't be flushed too early to interrupt the data stream\n          queueTask(() => {\n            controller.enqueue((0, _encodedecode.encodeText)(suffix));\n            res();\n          });\n        });\n      }\n    },\n    flush(controller) {\n      if (suffixFlushTask) return suffixFlushTask;\n      if (!suffixFlushed && suffix.length) {\n        suffixFlushed = true;\n        controller.enqueue((0, _encodedecode.encodeText)(suffix));\n      }\n    }\n  });\n}\nfunction createInlineDataStream(dataStream) {\n  let dataStreamFinished = null;\n  return new TransformStream({\n    transform(chunk, controller) {\n      controller.enqueue(chunk);\n      if (!dataStreamFinished) {\n        const dataStreamReader = dataStream.getReader();\n        // NOTE: streaming flush\n        // We are buffering here for the inlined data stream because the\n        // \"shell\" stream might be chunkenized again by the underlying stream\n        // implementation, e.g. with a specific high-water mark. To ensure it's\n        // the safe timing to pipe the data stream, this extra tick is\n        // necessary.\n        dataStreamFinished = new Promise(res =>\n        // We use `setTimeout` here to ensure that it's inserted after flushing\n        // the shell. Note that this implementation might get stale if impl\n        // details of Fizz change in the future.\n        // Also we are not using `setImmediate` here because it's not available\n        // broadly in all runtimes, for example some edge workers might not\n        // have it.\n        setTimeout(async () => {\n          try {\n            while (true) {\n              const {\n                done,\n                value\n              } = await dataStreamReader.read();\n              if (done) {\n                return res();\n              }\n              controller.enqueue(value);\n            }\n          } catch (err) {\n            controller.error(err);\n          }\n          res();\n        }, 0));\n      }\n    },\n    flush() {\n      if (dataStreamFinished) {\n        return dataStreamFinished;\n      }\n    }\n  });\n}\n/**\n * This transform stream moves the suffix to the end of the stream, so results\n * like `</body></html><script>...</script>` will be transformed to\n * `<script>...</script></body></html>`.\n */\nfunction createMoveSuffixStream(suffix) {\n  let foundSuffix = false;\n  const textDecoder = new TextDecoder();\n  // Remove suffix from the stream, and enqueue it back in flush\n  return new TransformStream({\n    transform(chunk, controller) {\n      if (!suffix || foundSuffix) {\n        return controller.enqueue(chunk);\n      }\n      const content = (0, _encodedecode.decodeText)(chunk, textDecoder);\n      if (content.endsWith(suffix)) {\n        foundSuffix = true;\n        const contentWithoutSuffix = content.slice(0, -suffix.length);\n        controller.enqueue((0, _encodedecode.encodeText)(contentWithoutSuffix));\n      } else {\n        controller.enqueue(chunk);\n      }\n    },\n    flush(controller) {\n      if (suffix) {\n        controller.enqueue((0, _encodedecode.encodeText)(suffix));\n      }\n    }\n  });\n}\nfunction createRootLayoutValidatorStream(assetPrefix = \"\", getTree) {\n  let foundHtml = false;\n  let foundBody = false;\n  const textDecoder = new TextDecoder();\n  return new TransformStream({\n    async transform(chunk, controller) {\n      if (!foundHtml || !foundBody) {\n        const content = (0, _encodedecode.decodeText)(chunk, textDecoder);\n        if (!foundHtml && content.includes(\"<html\")) {\n          foundHtml = true;\n        }\n        if (!foundBody && content.includes(\"<body\")) {\n          foundBody = true;\n        }\n      }\n      controller.enqueue(chunk);\n    },\n    flush(controller) {\n      // If html or body tag is missing, we need to inject a script to notify\n      // the client.\n      if (!foundHtml || !foundBody) {\n        const missingTags = [foundHtml ? null : \"html\", foundBody ? null : \"body\"].filter(_nonnullable.nonNullable);\n        controller.enqueue((0, _encodedecode.encodeText)(`<script>self.__next_root_layout_missing_tags_error=${JSON.stringify({\n          missingTags,\n          assetPrefix: assetPrefix ?? \"\",\n          tree: getTree()\n        })}</script>`));\n      }\n    }\n  });\n}\nasync function continueFromInitialStream(renderStream, {\n  suffix,\n  dataStream,\n  generateStaticHTML,\n  getServerInsertedHTML,\n  serverInsertedHTMLToHead,\n  validateRootLayout\n}) {\n  const closeTag = \"</body></html>\";\n  // Suffix itself might contain close tags at the end, so we need to split it.\n  const suffixUnclosed = suffix ? suffix.split(closeTag)[0] : null;\n  if (generateStaticHTML) {\n    await renderStream.allReady;\n  }\n  const transforms = [\n  // Buffer everything to avoid flushing too frequently\n  createBufferedTransformStream(),\n  // Insert generated tags to head\n  getServerInsertedHTML && !serverInsertedHTMLToHead ? createInsertedHTMLStream(getServerInsertedHTML) : null,\n  // Insert suffix content\n  suffixUnclosed != null ? createDeferredSuffixStream(suffixUnclosed) : null,\n  // Insert the flight data stream\n  dataStream ? createInlineDataStream(dataStream) : null,\n  // Close tags should always be deferred to the end\n  createMoveSuffixStream(closeTag),\n  // Special head insertions\n  // TODO-APP: Insert server side html to end of head in app layout rendering, to avoid\n  // hydration errors. Remove this once it's ready to be handled by react itself.\n  getServerInsertedHTML && serverInsertedHTMLToHead ? createHeadInsertionTransformStream(getServerInsertedHTML) : null, validateRootLayout ? createRootLayoutValidatorStream(validateRootLayout.assetPrefix, validateRootLayout.getTree) : null].filter(_nonnullable.nonNullable);\n  return transforms.reduce((readable, transform) => readable.pipeThrough(transform), renderStream);\n}","map":{"version":3,"names":["streamToBufferedResult","cloneTransformStream","chainStreams","streamFromString","streamToString","createBufferedTransformStream","createInsertedHTMLStream","renderToInitialStream","createInlineDataStream","createRootLayoutValidatorStream","continueFromInitialStream","queueTask","process","env","NEXT_RUNTIME","globalThis","setTimeout","setImmediate","renderResult","renderChunks","textDecoder","TextDecoder","writable","write","chunk","push","_encodedecode","decodeText","end","on","off","pipe","join","source","sourceReader","readable","getReader","clone","TransformStream","start","controller","done","value","read","enqueue","transform","streams","promise","Promise","resolve","i","length","then","pipeTo","preventClose","str","ReadableStream","encodeText","close","stream","reader","bufferedString","bufferedBytes","Uint8Array","pendingFlush","flushBuffer","newBufferedBytes","byteLength","set","flush","getServerInsertedHTML","insertedHTMLChunk","ReactDOMServer","element","streamOptions","_tracer","getTracer","trace","_constants","AppRenderSpan","renderToReadableStream","createHeadInsertionTransformStream","insert","inserted","freezing","insertion","content","index","indexOf","insertedHeadContent","slice","createDeferredSuffixStream","suffix","suffixFlushed","suffixFlushTask","res","dataStream","dataStreamFinished","dataStreamReader","err","error","createMoveSuffixStream","foundSuffix","endsWith","contentWithoutSuffix","assetPrefix","getTree","foundHtml","foundBody","includes","missingTags","filter","_nonnullable","nonNullable","JSON","stringify","tree","renderStream","generateStaticHTML","serverInsertedHTMLToHead","validateRootLayout","closeTag","suffixUnclosed","split","allReady","transforms","reduce","pipeThrough"],"sources":["../../../src/server/stream-utils/node-web-streams-helper.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}