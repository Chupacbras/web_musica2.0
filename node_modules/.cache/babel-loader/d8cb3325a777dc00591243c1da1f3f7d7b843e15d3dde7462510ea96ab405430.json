{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  validateTags: null,\n  addImplicitTags: null,\n  patchFetch: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  validateTags: function () {\n    return validateTags;\n  },\n  addImplicitTags: function () {\n    return addImplicitTags;\n  },\n  patchFetch: function () {\n    return patchFetch;\n  }\n});\nconst _constants = require(\"./trace/constants\");\nconst _tracer = require(\"./trace/tracer\");\nconst _constants1 = require(\"../../lib/constants\");\nconst _log = /*#__PURE__*/_interop_require_wildcard(require(\"../../build/output/log\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nconst isEdgeRuntime = process.env.NEXT_RUNTIME === \"edge\";\nfunction validateTags(tags, description) {\n  const validTags = [];\n  const invalidTags = [];\n  for (const tag of tags) {\n    if (typeof tag !== \"string\") {\n      invalidTags.push({\n        tag,\n        reason: \"invalid type, must be a string\"\n      });\n    } else if (tag.length > _constants1.NEXT_CACHE_TAG_MAX_LENGTH) {\n      invalidTags.push({\n        tag,\n        reason: `exceeded max length of ${_constants1.NEXT_CACHE_TAG_MAX_LENGTH}`\n      });\n    } else {\n      validTags.push(tag);\n    }\n  }\n  if (invalidTags.length > 0) {\n    console.warn(`Warning: invalid tags passed to ${description}: `);\n    for (const {\n      tag,\n      reason\n    } of invalidTags) {\n      console.log(`tag: \"${tag}\" ${reason}`);\n    }\n  }\n  return validTags;\n}\nconst getDerivedTags = pathname => {\n  const derivedTags = [`/layout`];\n  // we automatically add the current path segments as tags\n  // for revalidatePath handling\n  if (pathname.startsWith(\"/\")) {\n    const pathnameParts = pathname.split(\"/\");\n    for (let i = 1; i < pathnameParts.length + 1; i++) {\n      let curPathname = pathnameParts.slice(0, i).join(\"/\");\n      if (curPathname) {\n        // all derived tags other than the page are layout tags\n        if (!curPathname.endsWith(\"/page\") && !curPathname.endsWith(\"/route\")) {\n          curPathname = `${curPathname}${!curPathname.endsWith(\"/\") ? \"/\" : \"\"}layout`;\n        }\n        derivedTags.push(curPathname);\n      }\n    }\n  }\n  return derivedTags;\n};\nfunction addImplicitTags(staticGenerationStore) {\n  const newTags = [];\n  if (!staticGenerationStore) {\n    return newTags;\n  }\n  const {\n    pagePath,\n    urlPathname\n  } = staticGenerationStore;\n  if (!Array.isArray(staticGenerationStore.tags)) {\n    staticGenerationStore.tags = [];\n  }\n  if (pagePath) {\n    const derivedTags = getDerivedTags(pagePath);\n    for (let tag of derivedTags) {\n      var _staticGenerationStore_tags;\n      tag = `${_constants1.NEXT_CACHE_IMPLICIT_TAG_ID}${tag}`;\n      if (!((_staticGenerationStore_tags = staticGenerationStore.tags) == null ? void 0 : _staticGenerationStore_tags.includes(tag))) {\n        staticGenerationStore.tags.push(tag);\n      }\n      newTags.push(tag);\n    }\n  }\n  if (urlPathname) {\n    var _staticGenerationStore_tags1;\n    const tag = `${_constants1.NEXT_CACHE_IMPLICIT_TAG_ID}${urlPathname}`;\n    if (!((_staticGenerationStore_tags1 = staticGenerationStore.tags) == null ? void 0 : _staticGenerationStore_tags1.includes(tag))) {\n      staticGenerationStore.tags.push(tag);\n    }\n    newTags.push(tag);\n  }\n  return newTags;\n}\nfunction trackFetchMetric(staticGenerationStore, ctx) {\n  if (!staticGenerationStore) return;\n  if (!staticGenerationStore.fetchMetrics) {\n    staticGenerationStore.fetchMetrics = [];\n  }\n  const dedupeFields = [\"url\", \"status\", \"method\"];\n  // don't add metric if one already exists for the fetch\n  if (staticGenerationStore.fetchMetrics.some(metric => {\n    return dedupeFields.every(field => metric[field] === ctx[field]);\n  })) {\n    return;\n  }\n  staticGenerationStore.fetchMetrics.push({\n    url: ctx.url,\n    cacheStatus: ctx.cacheStatus,\n    cacheReason: ctx.cacheReason,\n    status: ctx.status,\n    method: ctx.method,\n    start: ctx.start,\n    end: Date.now(),\n    idx: staticGenerationStore.nextFetchId || 0\n  });\n}\nfunction patchFetch({\n  serverHooks,\n  staticGenerationAsyncStorage\n}) {\n  if (!globalThis._nextOriginalFetch) {\n    globalThis._nextOriginalFetch = globalThis.fetch;\n  }\n  if (globalThis.fetch.__nextPatched) return;\n  const {\n    DynamicServerError\n  } = serverHooks;\n  const originFetch = globalThis._nextOriginalFetch;\n  globalThis.fetch = async (input, init) => {\n    var _init_method, _this;\n    let url;\n    try {\n      url = new URL(input instanceof Request ? input.url : input);\n      url.username = \"\";\n      url.password = \"\";\n    } catch {\n      // Error caused by malformed URL should be handled by native fetch\n      url = undefined;\n    }\n    const fetchUrl = (url == null ? void 0 : url.href) ?? \"\";\n    const fetchStart = Date.now();\n    const method = (init == null ? void 0 : (_init_method = init.method) == null ? void 0 : _init_method.toUpperCase()) || \"GET\";\n    // Do create a new span trace for internal fetches in the\n    // non-verbose mode.\n    const isInternal = ((_this = init == null ? void 0 : init.next) == null ? void 0 : _this.internal) === true;\n    return await (0, _tracer.getTracer)().trace(isInternal ? _constants.NextNodeServerSpan.internalFetch : _constants.AppRenderSpan.fetch, {\n      kind: _tracer.SpanKind.CLIENT,\n      spanName: [\"fetch\", method, fetchUrl].filter(Boolean).join(\" \"),\n      attributes: {\n        \"http.url\": fetchUrl,\n        \"http.method\": method,\n        \"net.peer.name\": url == null ? void 0 : url.hostname,\n        \"net.peer.port\": (url == null ? void 0 : url.port) || undefined\n      }\n    }, async () => {\n      var _getRequestMeta;\n      const staticGenerationStore = staticGenerationAsyncStorage.getStore() || (fetch.__nextGetStaticStore == null ? void 0 : fetch.__nextGetStaticStore.call(fetch));\n      const isRequestInput = input && typeof input === \"object\" && typeof input.method === \"string\";\n      const getRequestMeta = field => {\n        let value = isRequestInput ? input[field] : null;\n        return value || (init == null ? void 0 : init[field]);\n      };\n      // If the staticGenerationStore is not available, we can't do any\n      // special treatment of fetch, therefore fallback to the original\n      // fetch implementation.\n      if (!staticGenerationStore || isInternal || staticGenerationStore.isDraftMode) {\n        return originFetch(input, init);\n      }\n      let revalidate = undefined;\n      const getNextField = field => {\n        var _init_next, _init_next1, _input_next;\n        return typeof (init == null ? void 0 : (_init_next = init.next) == null ? void 0 : _init_next[field]) !== \"undefined\" ? init == null ? void 0 : (_init_next1 = init.next) == null ? void 0 : _init_next1[field] : isRequestInput ? (_input_next = input.next) == null ? void 0 : _input_next[field] : undefined;\n      };\n      // RequestInit doesn't keep extra fields e.g. next so it's\n      // only available if init is used separate\n      let curRevalidate = getNextField(\"revalidate\");\n      const tags = validateTags(getNextField(\"tags\") || [], `fetch ${input.toString()}`);\n      if (Array.isArray(tags)) {\n        if (!staticGenerationStore.tags) {\n          staticGenerationStore.tags = [];\n        }\n        for (const tag of tags) {\n          if (!staticGenerationStore.tags.includes(tag)) {\n            staticGenerationStore.tags.push(tag);\n          }\n        }\n      }\n      const implicitTags = addImplicitTags(staticGenerationStore);\n      const isOnlyCache = staticGenerationStore.fetchCache === \"only-cache\";\n      const isForceCache = staticGenerationStore.fetchCache === \"force-cache\";\n      const isDefaultCache = staticGenerationStore.fetchCache === \"default-cache\";\n      const isDefaultNoStore = staticGenerationStore.fetchCache === \"default-no-store\";\n      const isOnlyNoStore = staticGenerationStore.fetchCache === \"only-no-store\";\n      const isForceNoStore = staticGenerationStore.fetchCache === \"force-no-store\";\n      let _cache = getRequestMeta(\"cache\");\n      let cacheReason = \"\";\n      if (typeof _cache === \"string\" && typeof curRevalidate !== \"undefined\") {\n        _log.warn(`fetch for ${fetchUrl} on ${staticGenerationStore.urlPathname} specified \"cache: ${_cache}\" and \"revalidate: ${curRevalidate}\", only one should be specified.`);\n        _cache = undefined;\n      }\n      if (_cache === \"force-cache\") {\n        curRevalidate = false;\n      }\n      if ([\"no-cache\", \"no-store\"].includes(_cache || \"\")) {\n        curRevalidate = 0;\n        cacheReason = `cache: ${_cache}`;\n      }\n      if (typeof curRevalidate === \"number\" || curRevalidate === false) {\n        revalidate = curRevalidate;\n      }\n      const _headers = getRequestMeta(\"headers\");\n      const initHeaders = typeof (_headers == null ? void 0 : _headers.get) === \"function\" ? _headers : new Headers(_headers || {});\n      const hasUnCacheableHeader = initHeaders.get(\"authorization\") || initHeaders.get(\"cookie\");\n      const isUnCacheableMethod = ![\"get\", \"head\"].includes(((_getRequestMeta = getRequestMeta(\"method\")) == null ? void 0 : _getRequestMeta.toLowerCase()) || \"get\");\n      // if there are authorized headers or a POST method and\n      // dynamic data usage was present above the tree we bail\n      // e.g. if cookies() is used before an authed/POST fetch\n      const autoNoCache = (hasUnCacheableHeader || isUnCacheableMethod) && staticGenerationStore.revalidate === 0;\n      if (isForceNoStore) {\n        revalidate = 0;\n        cacheReason = \"fetchCache = force-no-store\";\n      }\n      if (isOnlyNoStore) {\n        if (_cache === \"force-cache\" || revalidate === 0) {\n          throw new Error(`cache: 'force-cache' used on fetch for ${fetchUrl} with 'export const fetchCache = 'only-no-store'`);\n        }\n        revalidate = 0;\n        cacheReason = \"fetchCache = only-no-store\";\n      }\n      if (isOnlyCache && _cache === \"no-store\") {\n        throw new Error(`cache: 'no-store' used on fetch for ${fetchUrl} with 'export const fetchCache = 'only-cache'`);\n      }\n      if (isForceCache && (typeof curRevalidate === \"undefined\" || curRevalidate === 0)) {\n        cacheReason = \"fetchCache = force-cache\";\n        revalidate = false;\n      }\n      if (typeof revalidate === \"undefined\") {\n        if (isDefaultCache) {\n          revalidate = false;\n          cacheReason = \"fetchCache = default-cache\";\n        } else if (autoNoCache) {\n          revalidate = 0;\n          cacheReason = \"auto no cache\";\n        } else if (isDefaultNoStore) {\n          revalidate = 0;\n          cacheReason = \"fetchCache = default-no-store\";\n        } else {\n          cacheReason = \"auto cache\";\n          revalidate = typeof staticGenerationStore.revalidate === \"boolean\" || typeof staticGenerationStore.revalidate === \"undefined\" ? false : staticGenerationStore.revalidate;\n        }\n      } else if (!cacheReason) {\n        cacheReason = `revalidate: ${revalidate}`;\n      }\n      if (\n      // we don't consider autoNoCache to switch to dynamic during\n      // revalidate although if it occurs during build we do\n      !autoNoCache && (typeof staticGenerationStore.revalidate === \"undefined\" || typeof revalidate === \"number\" && (staticGenerationStore.revalidate === false || typeof staticGenerationStore.revalidate === \"number\" && revalidate < staticGenerationStore.revalidate))) {\n        staticGenerationStore.revalidate = revalidate;\n      }\n      const isCacheableRevalidate = typeof revalidate === \"number\" && revalidate > 0 || revalidate === false;\n      let cacheKey;\n      if (staticGenerationStore.incrementalCache && isCacheableRevalidate) {\n        try {\n          cacheKey = await staticGenerationStore.incrementalCache.fetchCacheKey(fetchUrl, isRequestInput ? input : init);\n        } catch (err) {\n          console.error(`Failed to generate cache key for`, input);\n        }\n      }\n      const fetchIdx = staticGenerationStore.nextFetchId ?? 1;\n      staticGenerationStore.nextFetchId = fetchIdx + 1;\n      const normalizedRevalidate = typeof revalidate !== \"number\" ? _constants1.CACHE_ONE_YEAR : revalidate;\n      const doOriginalFetch = async (isStale, cacheReasonOverride) => {\n        const requestInputFields = [\"cache\", \"credentials\", \"headers\", \"integrity\", \"keepalive\", \"method\", \"mode\", \"redirect\", \"referrer\", \"referrerPolicy\", \"window\", \"duplex\",\n        // don't pass through signal when revalidating\n        ...(isStale ? [] : [\"signal\"])];\n        if (isRequestInput) {\n          const reqInput = input;\n          const reqOptions = {\n            body: reqInput._ogBody || reqInput.body\n          };\n          for (const field of requestInputFields) {\n            // @ts-expect-error custom fields\n            reqOptions[field] = reqInput[field];\n          }\n          input = new Request(reqInput.url, reqOptions);\n        } else if (init) {\n          const initialInit = init;\n          init = {\n            body: init._ogBody || init.body\n          };\n          for (const field of requestInputFields) {\n            // @ts-expect-error custom fields\n            init[field] = initialInit[field];\n          }\n        }\n        // add metadata to init without editing the original\n        const clonedInit = {\n          ...init,\n          next: {\n            ...(init == null ? void 0 : init.next),\n            fetchType: \"origin\",\n            fetchIdx\n          }\n        };\n        return originFetch(input, clonedInit).then(async res => {\n          if (!isStale) {\n            trackFetchMetric(staticGenerationStore, {\n              start: fetchStart,\n              url: fetchUrl,\n              cacheReason: cacheReasonOverride || cacheReason,\n              cacheStatus: revalidate === 0 || cacheReasonOverride ? \"skip\" : \"miss\",\n              status: res.status,\n              method: clonedInit.method || \"GET\"\n            });\n          }\n          if (res.status === 200 && staticGenerationStore.incrementalCache && cacheKey && isCacheableRevalidate) {\n            const bodyBuffer = Buffer.from(await res.arrayBuffer());\n            try {\n              await staticGenerationStore.incrementalCache.set(cacheKey, {\n                kind: \"FETCH\",\n                data: {\n                  headers: Object.fromEntries(res.headers.entries()),\n                  body: bodyBuffer.toString(\"base64\"),\n                  status: res.status,\n                  url: res.url\n                },\n                revalidate: normalizedRevalidate\n              }, {\n                fetchCache: true,\n                revalidate,\n                fetchUrl,\n                fetchIdx,\n                tags\n              });\n            } catch (err) {\n              console.warn(`Failed to set fetch cache`, input, err);\n            }\n            const response = new Response(bodyBuffer, {\n              headers: new Headers(res.headers),\n              status: res.status\n            });\n            Object.defineProperty(response, \"url\", {\n              value: res.url\n            });\n            return response;\n          }\n          return res;\n        });\n      };\n      let handleUnlock = () => Promise.resolve();\n      let cacheReasonOverride;\n      if (cacheKey && staticGenerationStore.incrementalCache) {\n        handleUnlock = await staticGenerationStore.incrementalCache.lock(cacheKey);\n        const entry = staticGenerationStore.isOnDemandRevalidate ? null : await staticGenerationStore.incrementalCache.get(cacheKey, {\n          fetchCache: true,\n          revalidate,\n          fetchUrl,\n          fetchIdx,\n          tags,\n          softTags: implicitTags\n        });\n        if (entry) {\n          await handleUnlock();\n        } else {\n          // in dev, incremental cache response will be null in case the browser adds `cache-control: no-cache` in the request headers\n          cacheReasonOverride = \"cache-control: no-cache (hard refresh)\";\n        }\n        if ((entry == null ? void 0 : entry.value) && entry.value.kind === \"FETCH\") {\n          // when stale and is revalidating we wait for fresh data\n          // so the revalidated entry has the updated data\n          if (!(staticGenerationStore.isRevalidate && entry.isStale)) {\n            if (entry.isStale) {\n              if (!staticGenerationStore.pendingRevalidates) {\n                staticGenerationStore.pendingRevalidates = [];\n              }\n              staticGenerationStore.pendingRevalidates.push(doOriginalFetch(true).catch(console.error));\n            }\n            const resData = entry.value.data;\n            let decodedBody;\n            if (process.env.NEXT_RUNTIME === \"edge\") {\n              const {\n                decode\n              } = require(\"../../shared/lib/base64-arraybuffer\");\n              decodedBody = decode(resData.body);\n            } else {\n              decodedBody = Buffer.from(resData.body, \"base64\").subarray();\n            }\n            trackFetchMetric(staticGenerationStore, {\n              start: fetchStart,\n              url: fetchUrl,\n              cacheReason,\n              cacheStatus: \"hit\",\n              status: resData.status || 200,\n              method: (init == null ? void 0 : init.method) || \"GET\"\n            });\n            const response = new Response(decodedBody, {\n              headers: resData.headers,\n              status: resData.status\n            });\n            Object.defineProperty(response, \"url\", {\n              value: entry.value.data.url\n            });\n            return response;\n          }\n        }\n      }\n      if (staticGenerationStore.isStaticGeneration) {\n        if (init && typeof init === \"object\") {\n          const cache = init.cache;\n          // Delete `cache` property as Cloudflare Workers will throw an error\n          if (isEdgeRuntime) {\n            delete init.cache;\n          }\n          if (cache === \"no-store\") {\n            staticGenerationStore.revalidate = 0;\n            const dynamicUsageReason = `no-store fetch ${input}${staticGenerationStore.urlPathname ? ` ${staticGenerationStore.urlPathname}` : \"\"}`;\n            const err = new DynamicServerError(dynamicUsageReason);\n            staticGenerationStore.dynamicUsageErr = err;\n            staticGenerationStore.dynamicUsageStack = err.stack;\n            staticGenerationStore.dynamicUsageDescription = dynamicUsageReason;\n          }\n          const hasNextConfig = (\"next\" in init);\n          const next = init.next || {};\n          if (typeof next.revalidate === \"number\" && (typeof staticGenerationStore.revalidate === \"undefined\" || typeof staticGenerationStore.revalidate === \"number\" && next.revalidate < staticGenerationStore.revalidate)) {\n            const forceDynamic = staticGenerationStore.forceDynamic;\n            if (!forceDynamic || next.revalidate !== 0) {\n              staticGenerationStore.revalidate = next.revalidate;\n            }\n            if (!forceDynamic && next.revalidate === 0) {\n              const dynamicUsageReason = `revalidate: ${next.revalidate} fetch ${input}${staticGenerationStore.urlPathname ? ` ${staticGenerationStore.urlPathname}` : \"\"}`;\n              const err = new DynamicServerError(dynamicUsageReason);\n              staticGenerationStore.dynamicUsageErr = err;\n              staticGenerationStore.dynamicUsageStack = err.stack;\n              staticGenerationStore.dynamicUsageDescription = dynamicUsageReason;\n            }\n          }\n          if (hasNextConfig) delete init.next;\n        }\n      }\n      return doOriginalFetch(false, cacheReasonOverride).finally(handleUnlock);\n    });\n  };\n  globalThis.fetch.__nextGetStaticStore = () => {\n    return staticGenerationAsyncStorage;\n  };\n  globalThis.fetch.__nextPatched = true;\n}","map":{"version":3,"names":["validateTags","addImplicitTags","patchFetch","isEdgeRuntime","process","env","NEXT_RUNTIME","tags","description","validTags","invalidTags","tag","push","reason","length","_constants1","NEXT_CACHE_TAG_MAX_LENGTH","console","warn","log","getDerivedTags","pathname","derivedTags","startsWith","pathnameParts","split","i","curPathname","slice","join","endsWith","staticGenerationStore","newTags","pagePath","urlPathname","Array","isArray","_staticGenerationStore_tags","NEXT_CACHE_IMPLICIT_TAG_ID","includes","_staticGenerationStore_tags1","trackFetchMetric","ctx","fetchMetrics","dedupeFields","some","metric","every","field","url","cacheStatus","cacheReason","status","method","start","end","Date","now","idx","nextFetchId","serverHooks","staticGenerationAsyncStorage","globalThis","_nextOriginalFetch","fetch","__nextPatched","DynamicServerError","originFetch","input","init","_init_method","_this","URL","Request","username","password","undefined","fetchUrl","href","fetchStart","toUpperCase","isInternal","next","internal","_tracer","getTracer","trace","_constants","NextNodeServerSpan","internalFetch","AppRenderSpan","kind","SpanKind","CLIENT","spanName","filter","Boolean","attributes","hostname","port","_getRequestMeta","getStore","__nextGetStaticStore","call","isRequestInput","getRequestMeta","value","isDraftMode","revalidate","getNextField","_init_next","_init_next1","_input_next","curRevalidate","toString","implicitTags","isOnlyCache","fetchCache","isForceCache","isDefaultCache","isDefaultNoStore","isOnlyNoStore","isForceNoStore","_cache","_log","_headers","initHeaders","get","Headers","hasUnCacheableHeader","isUnCacheableMethod","toLowerCase","autoNoCache","Error","isCacheableRevalidate","cacheKey","incrementalCache","fetchCacheKey","err","error","fetchIdx","normalizedRevalidate","CACHE_ONE_YEAR","doOriginalFetch","isStale","cacheReasonOverride","requestInputFields","reqInput","reqOptions","body","_ogBody","initialInit","clonedInit","fetchType","then","res","bodyBuffer","Buffer","from","arrayBuffer","set","data","headers","Object","fromEntries","entries","response","Response","defineProperty","handleUnlock","Promise","resolve","lock","entry","isOnDemandRevalidate","softTags","isRevalidate","pendingRevalidates","catch","resData","decodedBody","decode","require","subarray","isStaticGeneration","cache","dynamicUsageReason","dynamicUsageErr","dynamicUsageStack","stack","dynamicUsageDescription","hasNextConfig","forceDynamic","finally"],"sources":["../../../src/server/lib/patch-fetch.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}