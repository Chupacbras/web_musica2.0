{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"generateInterceptionRoutesRewrites\", {\n  enumerable: true,\n  get: function () {\n    return generateInterceptionRoutesRewrites;\n  }\n});\nconst _pathtoregexp = require(\"next/dist/compiled/path-to-regexp\");\nconst _approuterheaders = require(\"../client/components/app-router-headers\");\nconst _interceptionroutes = require(\"../server/future/helpers/interception-routes\");\n// a function that converts normalised paths (e.g. /foo/[bar]/[baz]) to the format expected by pathToRegexp (e.g. /foo/:bar/:baz)\nfunction toPathToRegexpPath(path) {\n  return path.replace(/\\[\\[?([^\\]]+)\\]\\]?/g, (_, capture) => {\n    // handle catch-all segments (e.g. /foo/bar/[...baz] or /foo/bar/[[...baz]])\n    if (capture.startsWith(\"...\")) {\n      return `:${capture.slice(3)}*`;\n    }\n    return \":\" + capture;\n  });\n}\n// for interception routes we don't have access to the dynamic segments from the\n// referrer route so we mark them as noop for the app renderer so that it\n// can retrieve them from the router state later on. This also allows us to\n// compile the route properly with path-to-regexp, otherwise it will throw\nfunction voidParamsBeforeInterceptionMarker(path) {\n  let newPath = [];\n  let foundInterceptionMarker = false;\n  for (const segment of path.split(\"/\")) {\n    if (_interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find(marker => segment.startsWith(marker))) {\n      foundInterceptionMarker = true;\n    }\n    if (segment.startsWith(\":\") && !foundInterceptionMarker) {\n      newPath.push(\"__NEXT_EMPTY_PARAM__\");\n    } else {\n      newPath.push(segment);\n    }\n  }\n  return newPath.join(\"/\");\n}\nfunction generateInterceptionRoutesRewrites(appPaths) {\n  const rewrites = [];\n  for (const appPath of appPaths) {\n    if ((0, _interceptionroutes.isInterceptionRouteAppPath)(appPath)) {\n      const {\n        interceptingRoute,\n        interceptedRoute\n      } = (0, _interceptionroutes.extractInterceptionRouteInformation)(appPath);\n      const normalizedInterceptingRoute = `${interceptingRoute !== \"/\" ? toPathToRegexpPath(interceptingRoute) : \"\"}/(.*)?`;\n      const normalizedInterceptedRoute = toPathToRegexpPath(interceptedRoute);\n      const normalizedAppPath = voidParamsBeforeInterceptionMarker(toPathToRegexpPath(appPath));\n      // pathToRegexp returns a regex that matches the path, but we need to\n      // convert it to a string that can be used in a header value\n      // to the format that Next/the proxy expects\n      let interceptingRouteRegex = (0, _pathtoregexp.pathToRegexp)(normalizedInterceptingRoute).toString().slice(2, -3);\n      rewrites.push({\n        source: normalizedInterceptedRoute,\n        destination: normalizedAppPath,\n        has: [{\n          type: \"header\",\n          key: _approuterheaders.NEXT_URL,\n          value: interceptingRouteRegex\n        }]\n      });\n    }\n  }\n  return rewrites;\n}","map":{"version":3,"names":["generateInterceptionRoutesRewrites","toPathToRegexpPath","path","replace","_","capture","startsWith","slice","voidParamsBeforeInterceptionMarker","newPath","foundInterceptionMarker","segment","split","_interceptionroutes","INTERCEPTION_ROUTE_MARKERS","find","marker","push","join","appPaths","rewrites","appPath","isInterceptionRouteAppPath","interceptingRoute","interceptedRoute","extractInterceptionRouteInformation","normalizedInterceptingRoute","normalizedInterceptedRoute","normalizedAppPath","interceptingRouteRegex","_pathtoregexp","pathToRegexp","toString","source","destination","has","type","key","_approuterheaders","NEXT_URL","value"],"sources":["../../src/lib/generate-interception-routes-rewrites.ts"],"sourcesContent":[null],"mappings":";;;;;+BA6CgB;;;WAAAA,kCAAA;;;8BA7Ca;kCACJ;oCAKlB;AAGP;AACA,SAASC,mBAAmBC,IAAY;EACtC,OAAOA,IAAA,CAAKC,OAAO,CAAC,uBAAuB,CAACC,CAAA,EAAGC,OAAA;IAC7C;IACA,IAAIA,OAAA,CAAQC,UAAU,CAAC,QAAQ;MAC7B,OAAQ,IAAGD,OAAA,CAAQE,KAAK,CAAC,EAAG,GAAE;IAChC;IACA,OAAO,MAAMF,OAAA;EACf;AACF;AAEA;AACA;AACA;AACA;AACA,SAASG,mCAAmCN,IAAY;EACtD,IAAIO,OAAA,GAAU,EAAE;EAEhB,IAAIC,uBAAA,GAA0B;EAC9B,KAAK,MAAMC,OAAA,IAAWT,IAAA,CAAKU,KAAK,CAAC,MAAM;IACrC,IACEC,mBAAA,CAAAC,0BAA0B,CAACC,IAAI,CAAEC,MAAA,IAAWL,OAAA,CAAQL,UAAU,CAACU,MAAA,IAC/D;MACAN,uBAAA,GAA0B;IAC5B;IAEA,IAAIC,OAAA,CAAQL,UAAU,CAAC,QAAQ,CAACI,uBAAA,EAAyB;MACvDD,OAAA,CAAQQ,IAAI,CAAC;IACf,OAAO;MACLR,OAAA,CAAQQ,IAAI,CAACN,OAAA;IACf;EACF;EAEA,OAAOF,OAAA,CAAQS,IAAI,CAAC;AACtB;AAEO,SAASlB,mCACdmB,QAAkB;EAElB,MAAMC,QAAA,GAAsB,EAAE;EAE9B,KAAK,MAAMC,OAAA,IAAWF,QAAA,EAAU;IAC9B,IAAI,IAAAN,mBAAA,CAAAS,0BAA0B,EAACD,OAAA,GAAU;MACvC,MAAM;QAAEE,iBAAiB;QAAEC;MAAgB,CAAE,GAC3C,IAAAX,mBAAA,CAAAY,mCAAmC,EAACJ,OAAA;MAEtC,MAAMK,2BAAA,GAA+B,GACnCH,iBAAA,KAAsB,MAAMtB,kBAAA,CAAmBsB,iBAAA,IAAqB,EACrE,QAAO;MAER,MAAMI,0BAAA,GAA6B1B,kBAAA,CAAmBuB,gBAAA;MACtD,MAAMI,iBAAA,GAAoBpB,kCAAA,CACxBP,kBAAA,CAAmBoB,OAAA;MAGrB;MACA;MACA;MACA,IAAIQ,sBAAA,GAAyB,IAAAC,aAAA,CAAAC,YAAY,EAACL,2BAAA,EACvCM,QAAQ,GACRzB,KAAK,CAAC,GAAG,CAAC;MAEba,QAAA,CAASH,IAAI,CAAC;QACZgB,MAAA,EAAQN,0BAAA;QACRO,WAAA,EAAaN,iBAAA;QACbO,GAAA,EAAK,CACH;UACEC,IAAA,EAAM;UACNC,GAAA,EAAKC,iBAAA,CAAAC,QAAQ;UACbC,KAAA,EAAOX;QACT;MAEJ;IACF;EACF;EAEA,OAAOT,QAAA;AACT"},"metadata":{},"sourceType":"script","externalDependencies":[]}