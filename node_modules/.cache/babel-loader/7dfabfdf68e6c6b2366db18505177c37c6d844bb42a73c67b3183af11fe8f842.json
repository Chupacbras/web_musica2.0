{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  NoSuchDeclarationError: null,\n  UnsupportedValueError: null,\n  extractExportedConstValue: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  NoSuchDeclarationError: function () {\n    return NoSuchDeclarationError;\n  },\n  UnsupportedValueError: function () {\n    return UnsupportedValueError;\n  },\n  extractExportedConstValue: function () {\n    return extractExportedConstValue;\n  }\n});\nclass NoSuchDeclarationError extends Error {}\nfunction isExportDeclaration(node) {\n  return node.type === \"ExportDeclaration\";\n}\nfunction isVariableDeclaration(node) {\n  return node.type === \"VariableDeclaration\";\n}\nfunction isIdentifier(node) {\n  return node.type === \"Identifier\";\n}\nfunction isBooleanLiteral(node) {\n  return node.type === \"BooleanLiteral\";\n}\nfunction isNullLiteral(node) {\n  return node.type === \"NullLiteral\";\n}\nfunction isStringLiteral(node) {\n  return node.type === \"StringLiteral\";\n}\nfunction isNumericLiteral(node) {\n  return node.type === \"NumericLiteral\";\n}\nfunction isArrayExpression(node) {\n  return node.type === \"ArrayExpression\";\n}\nfunction isObjectExpression(node) {\n  return node.type === \"ObjectExpression\";\n}\nfunction isKeyValueProperty(node) {\n  return node.type === \"KeyValueProperty\";\n}\nfunction isRegExpLiteral(node) {\n  return node.type === \"RegExpLiteral\";\n}\nfunction isTemplateLiteral(node) {\n  return node.type === \"TemplateLiteral\";\n}\nclass UnsupportedValueError extends Error {\n  constructor(message, paths) {\n    super(message);\n    // Generating \"path\" that looks like \"config.runtime[0].value\"\n    let codePath;\n    if (paths) {\n      codePath = \"\";\n      for (const path of paths) {\n        if (path[0] === \"[\") {\n          // \"array\" + \"[0]\"\n          codePath += path;\n        } else {\n          if (codePath === \"\") {\n            codePath = path;\n          } else {\n            // \"object\" + \".key\"\n            codePath += `.${path}`;\n          }\n        }\n      }\n    }\n    this.path = codePath;\n  }\n}\nfunction extractValue(node, path) {\n  if (isNullLiteral(node)) {\n    return null;\n  } else if (isBooleanLiteral(node)) {\n    // e.g. true / false\n    return node.value;\n  } else if (isStringLiteral(node)) {\n    // e.g. \"abc\"\n    return node.value;\n  } else if (isNumericLiteral(node)) {\n    // e.g. 123\n    return node.value;\n  } else if (isRegExpLiteral(node)) {\n    // e.g. /abc/i\n    return new RegExp(node.pattern, node.flags);\n  } else if (isIdentifier(node)) {\n    switch (node.value) {\n      case \"undefined\":\n        return undefined;\n      default:\n        throw new UnsupportedValueError(`Unknown identifier \"${node.value}\"`, path);\n    }\n  } else if (isArrayExpression(node)) {\n    // e.g. [1, 2, 3]\n    const arr = [];\n    for (let i = 0, len = node.elements.length; i < len; i++) {\n      const elem = node.elements[i];\n      if (elem) {\n        if (elem.spread) {\n          // e.g. [ ...a ]\n          throw new UnsupportedValueError(\"Unsupported spread operator in the Array Expression\", path);\n        }\n        arr.push(extractValue(elem.expression, path && [...path, `[${i}]`]));\n      } else {\n        // e.g. [1, , 2]\n        //         ^^\n        arr.push(undefined);\n      }\n    }\n    return arr;\n  } else if (isObjectExpression(node)) {\n    // e.g. { a: 1, b: 2 }\n    const obj = {};\n    for (const prop of node.properties) {\n      if (!isKeyValueProperty(prop)) {\n        // e.g. { ...a }\n        throw new UnsupportedValueError(\"Unsupported spread operator in the Object Expression\", path);\n      }\n      let key;\n      if (isIdentifier(prop.key)) {\n        // e.g. { a: 1, b: 2 }\n        key = prop.key.value;\n      } else if (isStringLiteral(prop.key)) {\n        // e.g. { \"a\": 1, \"b\": 2 }\n        key = prop.key.value;\n      } else {\n        throw new UnsupportedValueError(`Unsupported key type \"${prop.key.type}\" in the Object Expression`, path);\n      }\n      obj[key] = extractValue(prop.value, path && [...path, key]);\n    }\n    return obj;\n  } else if (isTemplateLiteral(node)) {\n    // e.g. `abc`\n    if (node.expressions.length !== 0) {\n      // TODO: should we add support for `${'e'}d${'g'}'e'`?\n      throw new UnsupportedValueError(\"Unsupported template literal with expressions\", path);\n    }\n    // When TemplateLiteral has 0 expressions, the length of quasis is always 1.\n    // Because when parsing TemplateLiteral, the parser yields the first quasi,\n    // then the first expression, then the next quasi, then the next expression, etc.,\n    // until the last quasi.\n    // Thus if there is no expression, the parser ends at the frst and also last quasis\n    //\n    // A \"cooked\" interpretation where backslashes have special meaning, while a\n    // \"raw\" interpretation where backslashes do not have special meaning\n    // https://exploringjs.com/impatient-js/ch_template-literals.html#template-strings-cooked-vs-raw\n    const [{\n      cooked,\n      raw\n    }] = node.quasis;\n    return cooked ?? raw;\n  } else {\n    throw new UnsupportedValueError(`Unsupported node type \"${node.type}\"`, path);\n  }\n}\nfunction extractExportedConstValue(module1, exportedName) {\n  for (const moduleItem of module1.body) {\n    if (!isExportDeclaration(moduleItem)) {\n      continue;\n    }\n    const declaration = moduleItem.declaration;\n    if (!isVariableDeclaration(declaration)) {\n      continue;\n    }\n    if (declaration.kind !== \"const\") {\n      continue;\n    }\n    for (const decl of declaration.declarations) {\n      if (isIdentifier(decl.id) && decl.id.value === exportedName && decl.init) {\n        return extractValue(decl.init, [exportedName]);\n      }\n    }\n  }\n  throw new NoSuchDeclarationError();\n}","map":{"version":3,"names":["NoSuchDeclarationError","UnsupportedValueError","extractExportedConstValue","Error","isExportDeclaration","node","type","isVariableDeclaration","isIdentifier","isBooleanLiteral","isNullLiteral","isStringLiteral","isNumericLiteral","isArrayExpression","isObjectExpression","isKeyValueProperty","isRegExpLiteral","isTemplateLiteral","constructor","message","paths","codePath","path","extractValue","value","RegExp","pattern","flags","undefined","arr","i","len","elements","length","elem","spread","push","expression","obj","prop","properties","key","expressions","cooked","raw","quasis","module1","exportedName","moduleItem","body","declaration","kind","decl","declarations","id","init"],"sources":["../../../src/build/analysis/extract-const-value.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}