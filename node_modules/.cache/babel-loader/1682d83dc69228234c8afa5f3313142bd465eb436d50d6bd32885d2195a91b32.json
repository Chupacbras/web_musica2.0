{"ast":null,"code":"/**\n * @license React\n * react-refresh-babel.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict';\n\n    function ReactFreshBabelPlugin(babel) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (typeof babel.env === 'function') {\n        // Only available in Babel 7.\n        var env = babel.env();\n        if (env !== 'development' && !opts.skipEnvCheck) {\n          throw new Error('React Refresh Babel transform should only be enabled in development environment. ' + 'Instead, the environment is: \"' + env + '\". If you want to override this check, pass {skipEnvCheck: true} as plugin options.');\n        }\n      }\n      var t = babel.types;\n      var refreshReg = t.identifier(opts.refreshReg || '$RefreshReg$');\n      var refreshSig = t.identifier(opts.refreshSig || '$RefreshSig$');\n      var registrationsByProgramPath = new Map();\n      function createRegistration(programPath, persistentID) {\n        var handle = programPath.scope.generateUidIdentifier('c');\n        if (!registrationsByProgramPath.has(programPath)) {\n          registrationsByProgramPath.set(programPath, []);\n        }\n        var registrations = registrationsByProgramPath.get(programPath);\n        registrations.push({\n          handle: handle,\n          persistentID: persistentID\n        });\n        return handle;\n      }\n      function isComponentishName(name) {\n        return typeof name === 'string' && name[0] >= 'A' && name[0] <= 'Z';\n      }\n      function findInnerComponents(inferredName, path, callback) {\n        var node = path.node;\n        switch (node.type) {\n          case 'Identifier':\n            {\n              if (!isComponentishName(node.name)) {\n                return false;\n              } // export default hoc(Foo)\n              // const X = hoc(Foo)\n\n              callback(inferredName, node, null);\n              return true;\n            }\n          case 'FunctionDeclaration':\n            {\n              // function Foo() {}\n              // export function Foo() {}\n              // export default function Foo() {}\n              callback(inferredName, node.id, null);\n              return true;\n            }\n          case 'ArrowFunctionExpression':\n            {\n              if (node.body.type === 'ArrowFunctionExpression') {\n                return false;\n              } // let Foo = () => {}\n              // export default hoc1(hoc2(() => {}))\n\n              callback(inferredName, node, path);\n              return true;\n            }\n          case 'FunctionExpression':\n            {\n              // let Foo = function() {}\n              // const Foo = hoc1(forwardRef(function renderFoo() {}))\n              // export default memo(function() {})\n              callback(inferredName, node, path);\n              return true;\n            }\n          case 'CallExpression':\n            {\n              var argsPath = path.get('arguments');\n              if (argsPath === undefined || argsPath.length === 0) {\n                return false;\n              }\n              var calleePath = path.get('callee');\n              switch (calleePath.node.type) {\n                case 'MemberExpression':\n                case 'Identifier':\n                  {\n                    var calleeSource = calleePath.getSource();\n                    var firstArgPath = argsPath[0];\n                    var innerName = inferredName + '$' + calleeSource;\n                    var foundInside = findInnerComponents(innerName, firstArgPath, callback);\n                    if (!foundInside) {\n                      return false;\n                    } // const Foo = hoc1(hoc2(() => {}))\n                    // export default memo(React.forwardRef(function() {}))\n\n                    callback(inferredName, node, path);\n                    return true;\n                  }\n                default:\n                  {\n                    return false;\n                  }\n              }\n            }\n          case 'VariableDeclarator':\n            {\n              var init = node.init;\n              if (init === null) {\n                return false;\n              }\n              var name = node.id.name;\n              if (!isComponentishName(name)) {\n                return false;\n              }\n              switch (init.type) {\n                case 'ArrowFunctionExpression':\n                case 'FunctionExpression':\n                  // Likely component definitions.\n                  break;\n                case 'CallExpression':\n                  {\n                    // Maybe a HOC.\n                    // Try to determine if this is some form of import.\n                    var callee = init.callee;\n                    var calleeType = callee.type;\n                    if (calleeType === 'Import') {\n                      return false;\n                    } else if (calleeType === 'Identifier') {\n                      if (callee.name.indexOf('require') === 0) {\n                        return false;\n                      } else if (callee.name.indexOf('import') === 0) {\n                        return false;\n                      } // Neither require nor import. Might be a HOC.\n                      // Pass through.\n                    }\n\n                    break;\n                  }\n                case 'TaggedTemplateExpression':\n                  // Maybe something like styled.div`...`\n                  break;\n                default:\n                  return false;\n              }\n              var initPath = path.get('init');\n              var _foundInside = findInnerComponents(inferredName, initPath, callback);\n              if (_foundInside) {\n                return true;\n              } // See if this identifier is used in JSX. Then it's a component.\n\n              var binding = path.scope.getBinding(name);\n              if (binding === undefined) {\n                return;\n              }\n              var isLikelyUsedAsType = false;\n              var referencePaths = binding.referencePaths;\n              for (var i = 0; i < referencePaths.length; i++) {\n                var ref = referencePaths[i];\n                if (ref.node && ref.node.type !== 'JSXIdentifier' && ref.node.type !== 'Identifier') {\n                  continue;\n                }\n                var refParent = ref.parent;\n                if (refParent.type === 'JSXOpeningElement') {\n                  isLikelyUsedAsType = true;\n                } else if (refParent.type === 'CallExpression') {\n                  var _callee = refParent.callee;\n                  var fnName = void 0;\n                  switch (_callee.type) {\n                    case 'Identifier':\n                      fnName = _callee.name;\n                      break;\n                    case 'MemberExpression':\n                      fnName = _callee.property.name;\n                      break;\n                  }\n                  switch (fnName) {\n                    case 'createElement':\n                    case 'jsx':\n                    case 'jsxDEV':\n                    case 'jsxs':\n                      isLikelyUsedAsType = true;\n                      break;\n                  }\n                }\n                if (isLikelyUsedAsType) {\n                  // const X = ... + later <X />\n                  callback(inferredName, init, initPath);\n                  return true;\n                }\n              }\n            }\n        }\n        return false;\n      }\n      function isBuiltinHook(hookName) {\n        switch (hookName) {\n          case 'useState':\n          case 'React.useState':\n          case 'useReducer':\n          case 'React.useReducer':\n          case 'useEffect':\n          case 'React.useEffect':\n          case 'useLayoutEffect':\n          case 'React.useLayoutEffect':\n          case 'useMemo':\n          case 'React.useMemo':\n          case 'useCallback':\n          case 'React.useCallback':\n          case 'useRef':\n          case 'React.useRef':\n          case 'useContext':\n          case 'React.useContext':\n          case 'useImperativeHandle':\n          case 'React.useImperativeHandle':\n          case 'useDebugValue':\n          case 'React.useDebugValue':\n            return true;\n          default:\n            return false;\n        }\n      }\n      function getHookCallsSignature(functionNode) {\n        var fnHookCalls = hookCalls.get(functionNode);\n        if (fnHookCalls === undefined) {\n          return null;\n        }\n        return {\n          key: fnHookCalls.map(function (call) {\n            return call.name + '{' + call.key + '}';\n          }).join('\\n'),\n          customHooks: fnHookCalls.filter(function (call) {\n            return !isBuiltinHook(call.name);\n          }).map(function (call) {\n            return t.cloneDeep(call.callee);\n          })\n        };\n      }\n      var hasForceResetCommentByFile = new WeakMap(); // We let user do /* @refresh reset */ to reset state in the whole file.\n\n      function hasForceResetComment(path) {\n        var file = path.hub.file;\n        var hasForceReset = hasForceResetCommentByFile.get(file);\n        if (hasForceReset !== undefined) {\n          return hasForceReset;\n        }\n        hasForceReset = false;\n        var comments = file.ast.comments;\n        for (var i = 0; i < comments.length; i++) {\n          var cmt = comments[i];\n          if (cmt.value.indexOf('@refresh reset') !== -1) {\n            hasForceReset = true;\n            break;\n          }\n        }\n        hasForceResetCommentByFile.set(file, hasForceReset);\n        return hasForceReset;\n      }\n      function createArgumentsForSignature(node, signature, scope) {\n        var key = signature.key,\n          customHooks = signature.customHooks;\n        var forceReset = hasForceResetComment(scope.path);\n        var customHooksInScope = [];\n        customHooks.forEach(function (callee) {\n          // Check if a corresponding binding exists where we emit the signature.\n          var bindingName;\n          switch (callee.type) {\n            case 'MemberExpression':\n              if (callee.object.type === 'Identifier') {\n                bindingName = callee.object.name;\n              }\n              break;\n            case 'Identifier':\n              bindingName = callee.name;\n              break;\n          }\n          if (scope.hasBinding(bindingName)) {\n            customHooksInScope.push(callee);\n          } else {\n            // We don't have anything to put in the array because Hook is out of scope.\n            // Since it could potentially have been edited, remount the component.\n            forceReset = true;\n          }\n        });\n        var finalKey = key;\n        if (typeof require === 'function' && !opts.emitFullSignatures) {\n          // Prefer to hash when we can (e.g. outside of ASTExplorer).\n          // This makes it deterministically compact, even if there's\n          // e.g. a useState initializer with some code inside.\n          // We also need it for www that has transforms like cx()\n          // that don't understand if something is part of a string.\n          finalKey = require('crypto').createHash('sha1').update(key).digest('base64');\n        }\n        var args = [node, t.stringLiteral(finalKey)];\n        if (forceReset || customHooksInScope.length > 0) {\n          args.push(t.booleanLiteral(forceReset));\n        }\n        if (customHooksInScope.length > 0) {\n          args.push(\n          // TODO: We could use an arrow here to be more compact.\n          // However, don't do it until AMA can run them natively.\n          t.functionExpression(null, [], t.blockStatement([t.returnStatement(t.arrayExpression(customHooksInScope))])));\n        }\n        return args;\n      }\n      function findHOCCallPathsAbove(path) {\n        var calls = [];\n        while (true) {\n          if (!path) {\n            return calls;\n          }\n          var parentPath = path.parentPath;\n          if (!parentPath) {\n            return calls;\n          }\n          if (\n          // hoc(_c = function() { })\n          parentPath.node.type === 'AssignmentExpression' && path.node === parentPath.node.right) {\n            // Ignore registrations.\n            path = parentPath;\n            continue;\n          }\n          if (\n          // hoc1(hoc2(...))\n          parentPath.node.type === 'CallExpression' && path.node !== parentPath.node.callee) {\n            calls.push(parentPath);\n            path = parentPath;\n            continue;\n          }\n          return calls; // Stop at other types.\n        }\n      }\n\n      var seenForRegistration = new WeakSet();\n      var seenForSignature = new WeakSet();\n      var seenForOutro = new WeakSet();\n      var hookCalls = new WeakMap();\n      var HookCallsVisitor = {\n        CallExpression: function (path) {\n          var node = path.node;\n          var callee = node.callee; // Note: this visitor MUST NOT mutate the tree in any way.\n          // It runs early in a separate traversal and should be very fast.\n\n          var name = null;\n          switch (callee.type) {\n            case 'Identifier':\n              name = callee.name;\n              break;\n            case 'MemberExpression':\n              name = callee.property.name;\n              break;\n          }\n          if (name === null || !/^use[A-Z]/.test(name)) {\n            return;\n          }\n          var fnScope = path.scope.getFunctionParent();\n          if (fnScope === null) {\n            return;\n          } // This is a Hook call. Record it.\n\n          var fnNode = fnScope.block;\n          if (!hookCalls.has(fnNode)) {\n            hookCalls.set(fnNode, []);\n          }\n          var hookCallsForFn = hookCalls.get(fnNode);\n          var key = '';\n          if (path.parent.type === 'VariableDeclarator') {\n            // TODO: if there is no LHS, consider some other heuristic.\n            key = path.parentPath.get('id').getSource();\n          } // Some built-in Hooks reset on edits to arguments.\n\n          var args = path.get('arguments');\n          if (name === 'useState' && args.length > 0) {\n            // useState second argument is initial state.\n            key += '(' + args[0].getSource() + ')';\n          } else if (name === 'useReducer' && args.length > 1) {\n            // useReducer second argument is initial state.\n            key += '(' + args[1].getSource() + ')';\n          }\n          hookCallsForFn.push({\n            callee: path.node.callee,\n            name: name,\n            key: key\n          });\n        }\n      };\n      return {\n        visitor: {\n          ExportDefaultDeclaration: function (path) {\n            var node = path.node;\n            var decl = node.declaration;\n            var declPath = path.get('declaration');\n            if (decl.type !== 'CallExpression') {\n              // For now, we only support possible HOC calls here.\n              // Named function declarations are handled in FunctionDeclaration.\n              // Anonymous direct exports like export default function() {}\n              // are currently ignored.\n              return;\n            } // Make sure we're not mutating the same tree twice.\n            // This can happen if another Babel plugin replaces parents.\n\n            if (seenForRegistration.has(node)) {\n              return;\n            }\n            seenForRegistration.add(node); // Don't mutate the tree above this point.\n            // This code path handles nested cases like:\n            // export default memo(() => {})\n            // In those cases it is more plausible people will omit names\n            // so they're worth handling despite possible false positives.\n            // More importantly, it handles the named case:\n            // export default memo(function Named() {})\n\n            var inferredName = '%default%';\n            var programPath = path.parentPath;\n            findInnerComponents(inferredName, declPath, function (persistentID, targetExpr, targetPath) {\n              if (targetPath === null) {\n                // For case like:\n                // export default hoc(Foo)\n                // we don't want to wrap Foo inside the call.\n                // Instead we assume it's registered at definition.\n                return;\n              }\n              var handle = createRegistration(programPath, persistentID);\n              targetPath.replaceWith(t.assignmentExpression('=', handle, targetExpr));\n            });\n          },\n          FunctionDeclaration: {\n            enter: function (path) {\n              var node = path.node;\n              var programPath;\n              var insertAfterPath;\n              var modulePrefix = '';\n              switch (path.parent.type) {\n                case 'Program':\n                  insertAfterPath = path;\n                  programPath = path.parentPath;\n                  break;\n                case 'TSModuleBlock':\n                  insertAfterPath = path;\n                  programPath = insertAfterPath.parentPath.parentPath;\n                  break;\n                case 'ExportNamedDeclaration':\n                  insertAfterPath = path.parentPath;\n                  programPath = insertAfterPath.parentPath;\n                  break;\n                case 'ExportDefaultDeclaration':\n                  insertAfterPath = path.parentPath;\n                  programPath = insertAfterPath.parentPath;\n                  break;\n                default:\n                  return;\n              } // These types can be nested in typescript namespace\n              // We need to find the export chain\n              // Or return if it stays local\n\n              if (path.parent.type === 'TSModuleBlock' || path.parent.type === 'ExportNamedDeclaration') {\n                while (programPath.type !== 'Program') {\n                  if (programPath.type === 'TSModuleDeclaration') {\n                    if (programPath.parentPath.type !== 'Program' && programPath.parentPath.type !== 'ExportNamedDeclaration') {\n                      return;\n                    }\n                    modulePrefix = programPath.node.id.name + '$' + modulePrefix;\n                  }\n                  programPath = programPath.parentPath;\n                }\n              }\n              var id = node.id;\n              if (id === null) {\n                // We don't currently handle anonymous default exports.\n                return;\n              }\n              var inferredName = id.name;\n              if (!isComponentishName(inferredName)) {\n                return;\n              } // Make sure we're not mutating the same tree twice.\n              // This can happen if another Babel plugin replaces parents.\n\n              if (seenForRegistration.has(node)) {\n                return;\n              }\n              seenForRegistration.add(node); // Don't mutate the tree above this point.\n\n              var innerName = modulePrefix + inferredName; // export function Named() {}\n              // function Named() {}\n\n              findInnerComponents(innerName, path, function (persistentID, targetExpr) {\n                var handle = createRegistration(programPath, persistentID);\n                insertAfterPath.insertAfter(t.expressionStatement(t.assignmentExpression('=', handle, targetExpr)));\n              });\n            },\n            exit: function (path) {\n              var node = path.node;\n              var id = node.id;\n              if (id === null) {\n                return;\n              }\n              var signature = getHookCallsSignature(node);\n              if (signature === null) {\n                return;\n              } // Make sure we're not mutating the same tree twice.\n              // This can happen if another Babel plugin replaces parents.\n\n              if (seenForSignature.has(node)) {\n                return;\n              }\n              seenForSignature.add(node); // Don't mutate the tree above this point.\n\n              var sigCallID = path.scope.generateUidIdentifier('_s');\n              path.scope.parent.push({\n                id: sigCallID,\n                init: t.callExpression(refreshSig, [])\n              }); // The signature call is split in two parts. One part is called inside the function.\n              // This is used to signal when first render happens.\n\n              path.get('body').unshiftContainer('body', t.expressionStatement(t.callExpression(sigCallID, []))); // The second call is around the function itself.\n              // This is used to associate a type with a signature.\n              // Unlike with $RefreshReg$, this needs to work for nested\n              // declarations too. So we need to search for a path where\n              // we can insert a statement rather than hard coding it.\n\n              var insertAfterPath = null;\n              path.find(function (p) {\n                if (p.parentPath.isBlock()) {\n                  insertAfterPath = p;\n                  return true;\n                }\n              });\n              if (insertAfterPath === null) {\n                return;\n              }\n              insertAfterPath.insertAfter(t.expressionStatement(t.callExpression(sigCallID, createArgumentsForSignature(id, signature, insertAfterPath.scope))));\n            }\n          },\n          'ArrowFunctionExpression|FunctionExpression': {\n            exit: function (path) {\n              var node = path.node;\n              var signature = getHookCallsSignature(node);\n              if (signature === null) {\n                return;\n              } // Make sure we're not mutating the same tree twice.\n              // This can happen if another Babel plugin replaces parents.\n\n              if (seenForSignature.has(node)) {\n                return;\n              }\n              seenForSignature.add(node); // Don't mutate the tree above this point.\n\n              var sigCallID = path.scope.generateUidIdentifier('_s');\n              path.scope.parent.push({\n                id: sigCallID,\n                init: t.callExpression(refreshSig, [])\n              }); // The signature call is split in two parts. One part is called inside the function.\n              // This is used to signal when first render happens.\n\n              if (path.node.body.type !== 'BlockStatement') {\n                path.node.body = t.blockStatement([t.returnStatement(path.node.body)]);\n              }\n              path.get('body').unshiftContainer('body', t.expressionStatement(t.callExpression(sigCallID, []))); // The second call is around the function itself.\n              // This is used to associate a type with a signature.\n\n              if (path.parent.type === 'VariableDeclarator') {\n                var insertAfterPath = null;\n                path.find(function (p) {\n                  if (p.parentPath.isBlock()) {\n                    insertAfterPath = p;\n                    return true;\n                  }\n                });\n                if (insertAfterPath === null) {\n                  return;\n                } // Special case when a function would get an inferred name:\n                // let Foo = () => {}\n                // let Foo = function() {}\n                // We'll add signature it on next line so that\n                // we don't mess up the inferred 'Foo' function name.\n\n                insertAfterPath.insertAfter(t.expressionStatement(t.callExpression(sigCallID, createArgumentsForSignature(path.parent.id, signature, insertAfterPath.scope)))); // Result: let Foo = () => {}; __signature(Foo, ...);\n              } else {\n                // let Foo = hoc(() => {})\n                var paths = [path].concat(findHOCCallPathsAbove(path));\n                paths.forEach(function (p) {\n                  p.replaceWith(t.callExpression(sigCallID, createArgumentsForSignature(p.node, signature, p.scope)));\n                }); // Result: let Foo = __signature(hoc(__signature(() => {}, ...)), ...)\n              }\n            }\n          },\n\n          VariableDeclaration: function (path) {\n            var node = path.node;\n            var programPath;\n            var insertAfterPath;\n            var modulePrefix = '';\n            switch (path.parent.type) {\n              case 'Program':\n                insertAfterPath = path;\n                programPath = path.parentPath;\n                break;\n              case 'TSModuleBlock':\n                insertAfterPath = path;\n                programPath = insertAfterPath.parentPath.parentPath;\n                break;\n              case 'ExportNamedDeclaration':\n                insertAfterPath = path.parentPath;\n                programPath = insertAfterPath.parentPath;\n                break;\n              case 'ExportDefaultDeclaration':\n                insertAfterPath = path.parentPath;\n                programPath = insertAfterPath.parentPath;\n                break;\n              default:\n                return;\n            } // These types can be nested in typescript namespace\n            // We need to find the export chain\n            // Or return if it stays local\n\n            if (path.parent.type === 'TSModuleBlock' || path.parent.type === 'ExportNamedDeclaration') {\n              while (programPath.type !== 'Program') {\n                if (programPath.type === 'TSModuleDeclaration') {\n                  if (programPath.parentPath.type !== 'Program' && programPath.parentPath.type !== 'ExportNamedDeclaration') {\n                    return;\n                  }\n                  modulePrefix = programPath.node.id.name + '$' + modulePrefix;\n                }\n                programPath = programPath.parentPath;\n              }\n            } // Make sure we're not mutating the same tree twice.\n            // This can happen if another Babel plugin replaces parents.\n\n            if (seenForRegistration.has(node)) {\n              return;\n            }\n            seenForRegistration.add(node); // Don't mutate the tree above this point.\n\n            var declPaths = path.get('declarations');\n            if (declPaths.length !== 1) {\n              return;\n            }\n            var declPath = declPaths[0];\n            var inferredName = declPath.node.id.name;\n            var innerName = modulePrefix + inferredName;\n            findInnerComponents(innerName, declPath, function (persistentID, targetExpr, targetPath) {\n              if (targetPath === null) {\n                // For case like:\n                // export const Something = hoc(Foo)\n                // we don't want to wrap Foo inside the call.\n                // Instead we assume it's registered at definition.\n                return;\n              }\n              var handle = createRegistration(programPath, persistentID);\n              if (targetPath.parent.type === 'VariableDeclarator') {\n                // Special case when a variable would get an inferred name:\n                // let Foo = () => {}\n                // let Foo = function() {}\n                // let Foo = styled.div``;\n                // We'll register it on next line so that\n                // we don't mess up the inferred 'Foo' function name.\n                // (eg: with @babel/plugin-transform-react-display-name or\n                // babel-plugin-styled-components)\n                insertAfterPath.insertAfter(t.expressionStatement(t.assignmentExpression('=', handle, declPath.node.id))); // Result: let Foo = () => {}; _c1 = Foo;\n              } else {\n                // let Foo = hoc(() => {})\n                targetPath.replaceWith(t.assignmentExpression('=', handle, targetExpr)); // Result: let Foo = hoc(_c1 = () => {})\n              }\n            });\n          },\n\n          Program: {\n            enter: function (path) {\n              // This is a separate early visitor because we need to collect Hook calls\n              // and \"const [foo, setFoo] = ...\" signatures before the destructuring\n              // transform mangles them. This extra traversal is not ideal for perf,\n              // but it's the best we can do until we stop transpiling destructuring.\n              path.traverse(HookCallsVisitor);\n            },\n            exit: function (path) {\n              var registrations = registrationsByProgramPath.get(path);\n              if (registrations === undefined) {\n                return;\n              } // Make sure we're not mutating the same tree twice.\n              // This can happen if another Babel plugin replaces parents.\n\n              var node = path.node;\n              if (seenForOutro.has(node)) {\n                return;\n              }\n              seenForOutro.add(node); // Don't mutate the tree above this point.\n\n              registrationsByProgramPath.delete(path);\n              var declarators = [];\n              path.pushContainer('body', t.variableDeclaration('var', declarators));\n              registrations.forEach(function (_ref) {\n                var handle = _ref.handle,\n                  persistentID = _ref.persistentID;\n                path.pushContainer('body', t.expressionStatement(t.callExpression(refreshReg, [handle, t.stringLiteral(persistentID)])));\n                declarators.push(t.variableDeclarator(handle));\n              });\n            }\n          }\n        }\n      };\n    }\n    module.exports = ReactFreshBabelPlugin;\n  })();\n}","map":{"version":3,"names":["process","env","NODE_ENV","ReactFreshBabelPlugin","babel","opts","arguments","length","undefined","skipEnvCheck","Error","t","types","refreshReg","identifier","refreshSig","registrationsByProgramPath","Map","createRegistration","programPath","persistentID","handle","scope","generateUidIdentifier","has","set","registrations","get","push","isComponentishName","name","findInnerComponents","inferredName","path","callback","node","type","id","body","argsPath","calleePath","calleeSource","getSource","firstArgPath","innerName","foundInside","init","callee","calleeType","indexOf","initPath","_foundInside","binding","getBinding","isLikelyUsedAsType","referencePaths","i","ref","refParent","parent","_callee","fnName","property","isBuiltinHook","hookName","getHookCallsSignature","functionNode","fnHookCalls","hookCalls","key","map","call","join","customHooks","filter","cloneDeep","hasForceResetCommentByFile","WeakMap","hasForceResetComment","file","hub","hasForceReset","comments","ast","cmt","value","createArgumentsForSignature","signature","forceReset","customHooksInScope","forEach","bindingName","object","hasBinding","finalKey","require","emitFullSignatures","createHash","update","digest","args","stringLiteral","booleanLiteral","functionExpression","blockStatement","returnStatement","arrayExpression","findHOCCallPathsAbove","calls","parentPath","right","seenForRegistration","WeakSet","seenForSignature","seenForOutro","HookCallsVisitor","CallExpression","test","fnScope","getFunctionParent","fnNode","block","hookCallsForFn","visitor","ExportDefaultDeclaration","decl","declaration","declPath","add","targetExpr","targetPath","replaceWith","assignmentExpression","FunctionDeclaration","enter","insertAfterPath","modulePrefix","insertAfter","expressionStatement","exit","sigCallID","callExpression","unshiftContainer","find","p","isBlock","paths","concat","VariableDeclaration","declPaths","Program","traverse","delete","declarators","pushContainer","variableDeclaration","_ref","variableDeclarator","module","exports"],"sources":["/Users/albertformatger/Documents/GitHub/web_musica/node_modules/next/dist/compiled/react-refresh/cjs/react-refresh-babel.development.js"],"sourcesContent":["/**\n * @license React\n * react-refresh-babel.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nfunction ReactFreshBabelPlugin (babel) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof babel.env === 'function') {\n    // Only available in Babel 7.\n    var env = babel.env();\n\n    if (env !== 'development' && !opts.skipEnvCheck) {\n      throw new Error('React Refresh Babel transform should only be enabled in development environment. ' + 'Instead, the environment is: \"' + env + '\". If you want to override this check, pass {skipEnvCheck: true} as plugin options.');\n    }\n  }\n\n  var t = babel.types;\n  var refreshReg = t.identifier(opts.refreshReg || '$RefreshReg$');\n  var refreshSig = t.identifier(opts.refreshSig || '$RefreshSig$');\n  var registrationsByProgramPath = new Map();\n\n  function createRegistration(programPath, persistentID) {\n    var handle = programPath.scope.generateUidIdentifier('c');\n\n    if (!registrationsByProgramPath.has(programPath)) {\n      registrationsByProgramPath.set(programPath, []);\n    }\n\n    var registrations = registrationsByProgramPath.get(programPath);\n    registrations.push({\n      handle: handle,\n      persistentID: persistentID\n    });\n    return handle;\n  }\n\n  function isComponentishName(name) {\n    return typeof name === 'string' && name[0] >= 'A' && name[0] <= 'Z';\n  }\n\n  function findInnerComponents(inferredName, path, callback) {\n    var node = path.node;\n\n    switch (node.type) {\n      case 'Identifier':\n        {\n          if (!isComponentishName(node.name)) {\n            return false;\n          } // export default hoc(Foo)\n          // const X = hoc(Foo)\n\n\n          callback(inferredName, node, null);\n          return true;\n        }\n\n      case 'FunctionDeclaration':\n        {\n          // function Foo() {}\n          // export function Foo() {}\n          // export default function Foo() {}\n          callback(inferredName, node.id, null);\n          return true;\n        }\n\n      case 'ArrowFunctionExpression':\n        {\n          if (node.body.type === 'ArrowFunctionExpression') {\n            return false;\n          } // let Foo = () => {}\n          // export default hoc1(hoc2(() => {}))\n\n\n          callback(inferredName, node, path);\n          return true;\n        }\n\n      case 'FunctionExpression':\n        {\n          // let Foo = function() {}\n          // const Foo = hoc1(forwardRef(function renderFoo() {}))\n          // export default memo(function() {})\n          callback(inferredName, node, path);\n          return true;\n        }\n\n      case 'CallExpression':\n        {\n          var argsPath = path.get('arguments');\n\n          if (argsPath === undefined || argsPath.length === 0) {\n            return false;\n          }\n\n          var calleePath = path.get('callee');\n\n          switch (calleePath.node.type) {\n            case 'MemberExpression':\n            case 'Identifier':\n              {\n                var calleeSource = calleePath.getSource();\n                var firstArgPath = argsPath[0];\n                var innerName = inferredName + '$' + calleeSource;\n                var foundInside = findInnerComponents(innerName, firstArgPath, callback);\n\n                if (!foundInside) {\n                  return false;\n                } // const Foo = hoc1(hoc2(() => {}))\n                // export default memo(React.forwardRef(function() {}))\n\n\n                callback(inferredName, node, path);\n                return true;\n              }\n\n            default:\n              {\n                return false;\n              }\n          }\n        }\n\n      case 'VariableDeclarator':\n        {\n          var init = node.init;\n\n          if (init === null) {\n            return false;\n          }\n\n          var name = node.id.name;\n\n          if (!isComponentishName(name)) {\n            return false;\n          }\n\n          switch (init.type) {\n            case 'ArrowFunctionExpression':\n            case 'FunctionExpression':\n              // Likely component definitions.\n              break;\n\n            case 'CallExpression':\n              {\n                // Maybe a HOC.\n                // Try to determine if this is some form of import.\n                var callee = init.callee;\n                var calleeType = callee.type;\n\n                if (calleeType === 'Import') {\n                  return false;\n                } else if (calleeType === 'Identifier') {\n                  if (callee.name.indexOf('require') === 0) {\n                    return false;\n                  } else if (callee.name.indexOf('import') === 0) {\n                    return false;\n                  } // Neither require nor import. Might be a HOC.\n                  // Pass through.\n\n                }\n\n                break;\n              }\n\n            case 'TaggedTemplateExpression':\n              // Maybe something like styled.div`...`\n              break;\n\n            default:\n              return false;\n          }\n\n          var initPath = path.get('init');\n\n          var _foundInside = findInnerComponents(inferredName, initPath, callback);\n\n          if (_foundInside) {\n            return true;\n          } // See if this identifier is used in JSX. Then it's a component.\n\n\n          var binding = path.scope.getBinding(name);\n\n          if (binding === undefined) {\n            return;\n          }\n\n          var isLikelyUsedAsType = false;\n          var referencePaths = binding.referencePaths;\n\n          for (var i = 0; i < referencePaths.length; i++) {\n            var ref = referencePaths[i];\n\n            if (ref.node && ref.node.type !== 'JSXIdentifier' && ref.node.type !== 'Identifier') {\n              continue;\n            }\n\n            var refParent = ref.parent;\n\n            if (refParent.type === 'JSXOpeningElement') {\n              isLikelyUsedAsType = true;\n            } else if (refParent.type === 'CallExpression') {\n              var _callee = refParent.callee;\n              var fnName = void 0;\n\n              switch (_callee.type) {\n                case 'Identifier':\n                  fnName = _callee.name;\n                  break;\n\n                case 'MemberExpression':\n                  fnName = _callee.property.name;\n                  break;\n              }\n\n              switch (fnName) {\n                case 'createElement':\n                case 'jsx':\n                case 'jsxDEV':\n                case 'jsxs':\n                  isLikelyUsedAsType = true;\n                  break;\n              }\n            }\n\n            if (isLikelyUsedAsType) {\n              // const X = ... + later <X />\n              callback(inferredName, init, initPath);\n              return true;\n            }\n          }\n        }\n    }\n\n    return false;\n  }\n\n  function isBuiltinHook(hookName) {\n    switch (hookName) {\n      case 'useState':\n      case 'React.useState':\n      case 'useReducer':\n      case 'React.useReducer':\n      case 'useEffect':\n      case 'React.useEffect':\n      case 'useLayoutEffect':\n      case 'React.useLayoutEffect':\n      case 'useMemo':\n      case 'React.useMemo':\n      case 'useCallback':\n      case 'React.useCallback':\n      case 'useRef':\n      case 'React.useRef':\n      case 'useContext':\n      case 'React.useContext':\n      case 'useImperativeHandle':\n      case 'React.useImperativeHandle':\n      case 'useDebugValue':\n      case 'React.useDebugValue':\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  function getHookCallsSignature(functionNode) {\n    var fnHookCalls = hookCalls.get(functionNode);\n\n    if (fnHookCalls === undefined) {\n      return null;\n    }\n\n    return {\n      key: fnHookCalls.map(function (call) {\n        return call.name + '{' + call.key + '}';\n      }).join('\\n'),\n      customHooks: fnHookCalls.filter(function (call) {\n        return !isBuiltinHook(call.name);\n      }).map(function (call) {\n        return t.cloneDeep(call.callee);\n      })\n    };\n  }\n\n  var hasForceResetCommentByFile = new WeakMap(); // We let user do /* @refresh reset */ to reset state in the whole file.\n\n  function hasForceResetComment(path) {\n    var file = path.hub.file;\n    var hasForceReset = hasForceResetCommentByFile.get(file);\n\n    if (hasForceReset !== undefined) {\n      return hasForceReset;\n    }\n\n    hasForceReset = false;\n    var comments = file.ast.comments;\n\n    for (var i = 0; i < comments.length; i++) {\n      var cmt = comments[i];\n\n      if (cmt.value.indexOf('@refresh reset') !== -1) {\n        hasForceReset = true;\n        break;\n      }\n    }\n\n    hasForceResetCommentByFile.set(file, hasForceReset);\n    return hasForceReset;\n  }\n\n  function createArgumentsForSignature(node, signature, scope) {\n    var key = signature.key,\n        customHooks = signature.customHooks;\n    var forceReset = hasForceResetComment(scope.path);\n    var customHooksInScope = [];\n    customHooks.forEach(function (callee) {\n      // Check if a corresponding binding exists where we emit the signature.\n      var bindingName;\n\n      switch (callee.type) {\n        case 'MemberExpression':\n          if (callee.object.type === 'Identifier') {\n            bindingName = callee.object.name;\n          }\n\n          break;\n\n        case 'Identifier':\n          bindingName = callee.name;\n          break;\n      }\n\n      if (scope.hasBinding(bindingName)) {\n        customHooksInScope.push(callee);\n      } else {\n        // We don't have anything to put in the array because Hook is out of scope.\n        // Since it could potentially have been edited, remount the component.\n        forceReset = true;\n      }\n    });\n    var finalKey = key;\n\n    if (typeof require === 'function' && !opts.emitFullSignatures) {\n      // Prefer to hash when we can (e.g. outside of ASTExplorer).\n      // This makes it deterministically compact, even if there's\n      // e.g. a useState initializer with some code inside.\n      // We also need it for www that has transforms like cx()\n      // that don't understand if something is part of a string.\n      finalKey = require('crypto').createHash('sha1').update(key).digest('base64');\n    }\n\n    var args = [node, t.stringLiteral(finalKey)];\n\n    if (forceReset || customHooksInScope.length > 0) {\n      args.push(t.booleanLiteral(forceReset));\n    }\n\n    if (customHooksInScope.length > 0) {\n      args.push( // TODO: We could use an arrow here to be more compact.\n      // However, don't do it until AMA can run them natively.\n      t.functionExpression(null, [], t.blockStatement([t.returnStatement(t.arrayExpression(customHooksInScope))])));\n    }\n\n    return args;\n  }\n\n  function findHOCCallPathsAbove(path) {\n    var calls = [];\n\n    while (true) {\n      if (!path) {\n        return calls;\n      }\n\n      var parentPath = path.parentPath;\n\n      if (!parentPath) {\n        return calls;\n      }\n\n      if ( // hoc(_c = function() { })\n      parentPath.node.type === 'AssignmentExpression' && path.node === parentPath.node.right) {\n        // Ignore registrations.\n        path = parentPath;\n        continue;\n      }\n\n      if ( // hoc1(hoc2(...))\n      parentPath.node.type === 'CallExpression' && path.node !== parentPath.node.callee) {\n        calls.push(parentPath);\n        path = parentPath;\n        continue;\n      }\n\n      return calls; // Stop at other types.\n    }\n  }\n\n  var seenForRegistration = new WeakSet();\n  var seenForSignature = new WeakSet();\n  var seenForOutro = new WeakSet();\n  var hookCalls = new WeakMap();\n  var HookCallsVisitor = {\n    CallExpression: function (path) {\n      var node = path.node;\n      var callee = node.callee; // Note: this visitor MUST NOT mutate the tree in any way.\n      // It runs early in a separate traversal and should be very fast.\n\n      var name = null;\n\n      switch (callee.type) {\n        case 'Identifier':\n          name = callee.name;\n          break;\n\n        case 'MemberExpression':\n          name = callee.property.name;\n          break;\n      }\n\n      if (name === null || !/^use[A-Z]/.test(name)) {\n        return;\n      }\n\n      var fnScope = path.scope.getFunctionParent();\n\n      if (fnScope === null) {\n        return;\n      } // This is a Hook call. Record it.\n\n\n      var fnNode = fnScope.block;\n\n      if (!hookCalls.has(fnNode)) {\n        hookCalls.set(fnNode, []);\n      }\n\n      var hookCallsForFn = hookCalls.get(fnNode);\n      var key = '';\n\n      if (path.parent.type === 'VariableDeclarator') {\n        // TODO: if there is no LHS, consider some other heuristic.\n        key = path.parentPath.get('id').getSource();\n      } // Some built-in Hooks reset on edits to arguments.\n\n\n      var args = path.get('arguments');\n\n      if (name === 'useState' && args.length > 0) {\n        // useState second argument is initial state.\n        key += '(' + args[0].getSource() + ')';\n      } else if (name === 'useReducer' && args.length > 1) {\n        // useReducer second argument is initial state.\n        key += '(' + args[1].getSource() + ')';\n      }\n\n      hookCallsForFn.push({\n        callee: path.node.callee,\n        name: name,\n        key: key\n      });\n    }\n  };\n  return {\n    visitor: {\n      ExportDefaultDeclaration: function (path) {\n        var node = path.node;\n        var decl = node.declaration;\n        var declPath = path.get('declaration');\n\n        if (decl.type !== 'CallExpression') {\n          // For now, we only support possible HOC calls here.\n          // Named function declarations are handled in FunctionDeclaration.\n          // Anonymous direct exports like export default function() {}\n          // are currently ignored.\n          return;\n        } // Make sure we're not mutating the same tree twice.\n        // This can happen if another Babel plugin replaces parents.\n\n\n        if (seenForRegistration.has(node)) {\n          return;\n        }\n\n        seenForRegistration.add(node); // Don't mutate the tree above this point.\n        // This code path handles nested cases like:\n        // export default memo(() => {})\n        // In those cases it is more plausible people will omit names\n        // so they're worth handling despite possible false positives.\n        // More importantly, it handles the named case:\n        // export default memo(function Named() {})\n\n        var inferredName = '%default%';\n        var programPath = path.parentPath;\n        findInnerComponents(inferredName, declPath, function (persistentID, targetExpr, targetPath) {\n          if (targetPath === null) {\n            // For case like:\n            // export default hoc(Foo)\n            // we don't want to wrap Foo inside the call.\n            // Instead we assume it's registered at definition.\n            return;\n          }\n\n          var handle = createRegistration(programPath, persistentID);\n          targetPath.replaceWith(t.assignmentExpression('=', handle, targetExpr));\n        });\n      },\n      FunctionDeclaration: {\n        enter: function (path) {\n          var node = path.node;\n          var programPath;\n          var insertAfterPath;\n          var modulePrefix = '';\n\n          switch (path.parent.type) {\n            case 'Program':\n              insertAfterPath = path;\n              programPath = path.parentPath;\n              break;\n\n            case 'TSModuleBlock':\n              insertAfterPath = path;\n              programPath = insertAfterPath.parentPath.parentPath;\n              break;\n\n            case 'ExportNamedDeclaration':\n              insertAfterPath = path.parentPath;\n              programPath = insertAfterPath.parentPath;\n              break;\n\n            case 'ExportDefaultDeclaration':\n              insertAfterPath = path.parentPath;\n              programPath = insertAfterPath.parentPath;\n              break;\n\n            default:\n              return;\n          } // These types can be nested in typescript namespace\n          // We need to find the export chain\n          // Or return if it stays local\n\n\n          if (path.parent.type === 'TSModuleBlock' || path.parent.type === 'ExportNamedDeclaration') {\n            while (programPath.type !== 'Program') {\n              if (programPath.type === 'TSModuleDeclaration') {\n                if (programPath.parentPath.type !== 'Program' && programPath.parentPath.type !== 'ExportNamedDeclaration') {\n                  return;\n                }\n\n                modulePrefix = programPath.node.id.name + '$' + modulePrefix;\n              }\n\n              programPath = programPath.parentPath;\n            }\n          }\n\n          var id = node.id;\n\n          if (id === null) {\n            // We don't currently handle anonymous default exports.\n            return;\n          }\n\n          var inferredName = id.name;\n\n          if (!isComponentishName(inferredName)) {\n            return;\n          } // Make sure we're not mutating the same tree twice.\n          // This can happen if another Babel plugin replaces parents.\n\n\n          if (seenForRegistration.has(node)) {\n            return;\n          }\n\n          seenForRegistration.add(node); // Don't mutate the tree above this point.\n\n          var innerName = modulePrefix + inferredName; // export function Named() {}\n          // function Named() {}\n\n          findInnerComponents(innerName, path, function (persistentID, targetExpr) {\n            var handle = createRegistration(programPath, persistentID);\n            insertAfterPath.insertAfter(t.expressionStatement(t.assignmentExpression('=', handle, targetExpr)));\n          });\n        },\n        exit: function (path) {\n          var node = path.node;\n          var id = node.id;\n\n          if (id === null) {\n            return;\n          }\n\n          var signature = getHookCallsSignature(node);\n\n          if (signature === null) {\n            return;\n          } // Make sure we're not mutating the same tree twice.\n          // This can happen if another Babel plugin replaces parents.\n\n\n          if (seenForSignature.has(node)) {\n            return;\n          }\n\n          seenForSignature.add(node); // Don't mutate the tree above this point.\n\n          var sigCallID = path.scope.generateUidIdentifier('_s');\n          path.scope.parent.push({\n            id: sigCallID,\n            init: t.callExpression(refreshSig, [])\n          }); // The signature call is split in two parts. One part is called inside the function.\n          // This is used to signal when first render happens.\n\n          path.get('body').unshiftContainer('body', t.expressionStatement(t.callExpression(sigCallID, []))); // The second call is around the function itself.\n          // This is used to associate a type with a signature.\n          // Unlike with $RefreshReg$, this needs to work for nested\n          // declarations too. So we need to search for a path where\n          // we can insert a statement rather than hard coding it.\n\n          var insertAfterPath = null;\n          path.find(function (p) {\n            if (p.parentPath.isBlock()) {\n              insertAfterPath = p;\n              return true;\n            }\n          });\n\n          if (insertAfterPath === null) {\n            return;\n          }\n\n          insertAfterPath.insertAfter(t.expressionStatement(t.callExpression(sigCallID, createArgumentsForSignature(id, signature, insertAfterPath.scope))));\n        }\n      },\n      'ArrowFunctionExpression|FunctionExpression': {\n        exit: function (path) {\n          var node = path.node;\n          var signature = getHookCallsSignature(node);\n\n          if (signature === null) {\n            return;\n          } // Make sure we're not mutating the same tree twice.\n          // This can happen if another Babel plugin replaces parents.\n\n\n          if (seenForSignature.has(node)) {\n            return;\n          }\n\n          seenForSignature.add(node); // Don't mutate the tree above this point.\n\n          var sigCallID = path.scope.generateUidIdentifier('_s');\n          path.scope.parent.push({\n            id: sigCallID,\n            init: t.callExpression(refreshSig, [])\n          }); // The signature call is split in two parts. One part is called inside the function.\n          // This is used to signal when first render happens.\n\n          if (path.node.body.type !== 'BlockStatement') {\n            path.node.body = t.blockStatement([t.returnStatement(path.node.body)]);\n          }\n\n          path.get('body').unshiftContainer('body', t.expressionStatement(t.callExpression(sigCallID, []))); // The second call is around the function itself.\n          // This is used to associate a type with a signature.\n\n          if (path.parent.type === 'VariableDeclarator') {\n            var insertAfterPath = null;\n            path.find(function (p) {\n              if (p.parentPath.isBlock()) {\n                insertAfterPath = p;\n                return true;\n              }\n            });\n\n            if (insertAfterPath === null) {\n              return;\n            } // Special case when a function would get an inferred name:\n            // let Foo = () => {}\n            // let Foo = function() {}\n            // We'll add signature it on next line so that\n            // we don't mess up the inferred 'Foo' function name.\n\n\n            insertAfterPath.insertAfter(t.expressionStatement(t.callExpression(sigCallID, createArgumentsForSignature(path.parent.id, signature, insertAfterPath.scope)))); // Result: let Foo = () => {}; __signature(Foo, ...);\n          } else {\n            // let Foo = hoc(() => {})\n            var paths = [path].concat(findHOCCallPathsAbove(path));\n            paths.forEach(function (p) {\n              p.replaceWith(t.callExpression(sigCallID, createArgumentsForSignature(p.node, signature, p.scope)));\n            }); // Result: let Foo = __signature(hoc(__signature(() => {}, ...)), ...)\n          }\n        }\n      },\n      VariableDeclaration: function (path) {\n        var node = path.node;\n        var programPath;\n        var insertAfterPath;\n        var modulePrefix = '';\n\n        switch (path.parent.type) {\n          case 'Program':\n            insertAfterPath = path;\n            programPath = path.parentPath;\n            break;\n\n          case 'TSModuleBlock':\n            insertAfterPath = path;\n            programPath = insertAfterPath.parentPath.parentPath;\n            break;\n\n          case 'ExportNamedDeclaration':\n            insertAfterPath = path.parentPath;\n            programPath = insertAfterPath.parentPath;\n            break;\n\n          case 'ExportDefaultDeclaration':\n            insertAfterPath = path.parentPath;\n            programPath = insertAfterPath.parentPath;\n            break;\n\n          default:\n            return;\n        } // These types can be nested in typescript namespace\n        // We need to find the export chain\n        // Or return if it stays local\n\n\n        if (path.parent.type === 'TSModuleBlock' || path.parent.type === 'ExportNamedDeclaration') {\n          while (programPath.type !== 'Program') {\n            if (programPath.type === 'TSModuleDeclaration') {\n              if (programPath.parentPath.type !== 'Program' && programPath.parentPath.type !== 'ExportNamedDeclaration') {\n                return;\n              }\n\n              modulePrefix = programPath.node.id.name + '$' + modulePrefix;\n            }\n\n            programPath = programPath.parentPath;\n          }\n        } // Make sure we're not mutating the same tree twice.\n        // This can happen if another Babel plugin replaces parents.\n\n\n        if (seenForRegistration.has(node)) {\n          return;\n        }\n\n        seenForRegistration.add(node); // Don't mutate the tree above this point.\n\n        var declPaths = path.get('declarations');\n\n        if (declPaths.length !== 1) {\n          return;\n        }\n\n        var declPath = declPaths[0];\n        var inferredName = declPath.node.id.name;\n        var innerName = modulePrefix + inferredName;\n        findInnerComponents(innerName, declPath, function (persistentID, targetExpr, targetPath) {\n          if (targetPath === null) {\n            // For case like:\n            // export const Something = hoc(Foo)\n            // we don't want to wrap Foo inside the call.\n            // Instead we assume it's registered at definition.\n            return;\n          }\n\n          var handle = createRegistration(programPath, persistentID);\n\n          if (targetPath.parent.type === 'VariableDeclarator') {\n            // Special case when a variable would get an inferred name:\n            // let Foo = () => {}\n            // let Foo = function() {}\n            // let Foo = styled.div``;\n            // We'll register it on next line so that\n            // we don't mess up the inferred 'Foo' function name.\n            // (eg: with @babel/plugin-transform-react-display-name or\n            // babel-plugin-styled-components)\n            insertAfterPath.insertAfter(t.expressionStatement(t.assignmentExpression('=', handle, declPath.node.id))); // Result: let Foo = () => {}; _c1 = Foo;\n          } else {\n            // let Foo = hoc(() => {})\n            targetPath.replaceWith(t.assignmentExpression('=', handle, targetExpr)); // Result: let Foo = hoc(_c1 = () => {})\n          }\n        });\n      },\n      Program: {\n        enter: function (path) {\n          // This is a separate early visitor because we need to collect Hook calls\n          // and \"const [foo, setFoo] = ...\" signatures before the destructuring\n          // transform mangles them. This extra traversal is not ideal for perf,\n          // but it's the best we can do until we stop transpiling destructuring.\n          path.traverse(HookCallsVisitor);\n        },\n        exit: function (path) {\n          var registrations = registrationsByProgramPath.get(path);\n\n          if (registrations === undefined) {\n            return;\n          } // Make sure we're not mutating the same tree twice.\n          // This can happen if another Babel plugin replaces parents.\n\n\n          var node = path.node;\n\n          if (seenForOutro.has(node)) {\n            return;\n          }\n\n          seenForOutro.add(node); // Don't mutate the tree above this point.\n\n          registrationsByProgramPath.delete(path);\n          var declarators = [];\n          path.pushContainer('body', t.variableDeclaration('var', declarators));\n          registrations.forEach(function (_ref) {\n            var handle = _ref.handle,\n                persistentID = _ref.persistentID;\n            path.pushContainer('body', t.expressionStatement(t.callExpression(refreshReg, [handle, t.stringLiteral(persistentID)])));\n            declarators.push(t.variableDeclarator(handle));\n          });\n        }\n      }\n    }\n  };\n}\n\nmodule.exports = ReactFreshBabelPlugin;\n  })();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}