{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateGoogleFontFunctionCall = void 0;\nconst constants_1 = require(\"../constants\");\nconst format_available_values_1 = require(\"../format-available-values\");\nconst next_font_error_1 = require(\"../next-font-error\");\nconst google_fonts_metadata_1 = require(\"./google-fonts-metadata\");\n/**\n * Validate the data recieved from next-swc next-transform-font on next/font/google calls\n */\nfunction validateGoogleFontFunctionCall(functionName, fontFunctionArgument) {\n  let {\n    weight,\n    style,\n    preload = true,\n    display = 'swap',\n    axes,\n    fallback,\n    adjustFontFallback = true,\n    variable,\n    subsets\n  } = fontFunctionArgument || {};\n  if (functionName === '') {\n    (0, next_font_error_1.nextFontError)(`next/font/google has no default export`);\n  }\n  const fontFamily = functionName.replace(/_/g, ' ');\n  // Get the Google font metadata, we'll use this to validate the font arguments and to print better error messages\n  const fontFamilyData = google_fonts_metadata_1.googleFontsMetadata[fontFamily];\n  if (!fontFamilyData) {\n    (0, next_font_error_1.nextFontError)(`Unknown font \\`${fontFamily}\\``);\n  }\n  const availableSubsets = fontFamilyData.subsets;\n  if (availableSubsets.length === 0) {\n    // If the font doesn't have any preloadeable subsets, disable preload\n    preload = false;\n  } else if (preload) {\n    if (!subsets) {\n      (0, next_font_error_1.nextFontError)(`Preload is enabled but no subsets were specified for font \\`${fontFamily}\\`. Please specify subsets or disable preloading if your intended subset can't be preloaded.\\nAvailable subsets: ${(0, format_available_values_1.formatAvailableValues)(availableSubsets)}\\n\\nRead more: https://nextjs.org/docs/messages/google-fonts-missing-subsets`);\n    }\n    subsets.forEach(subset => {\n      if (!availableSubsets.includes(subset)) {\n        (0, next_font_error_1.nextFontError)(`Unknown subset \\`${subset}\\` for font \\`${fontFamily}\\`.\\nAvailable subsets: ${(0, format_available_values_1.formatAvailableValues)(availableSubsets)}`);\n      }\n    });\n  }\n  const fontWeights = fontFamilyData.weights;\n  const fontStyles = fontFamilyData.styles;\n  // Get the unique weights and styles from the function call\n  const weights = !weight ? [] : [...new Set(Array.isArray(weight) ? weight : [weight])];\n  const styles = !style ? [] : [...new Set(Array.isArray(style) ? style : [style])];\n  if (weights.length === 0) {\n    // Set variable as default, throw if not available\n    if (fontWeights.includes('variable')) {\n      weights.push('variable');\n    } else {\n      (0, next_font_error_1.nextFontError)(`Missing weight for font \\`${fontFamily}\\`.\\nAvailable weights: ${(0, format_available_values_1.formatAvailableValues)(fontWeights)}`);\n    }\n  }\n  if (weights.length > 1 && weights.includes('variable')) {\n    (0, next_font_error_1.nextFontError)(`Unexpected \\`variable\\` in weight array for font \\`${fontFamily}\\`. You only need \\`variable\\`, it includes all available weights.`);\n  }\n  weights.forEach(selectedWeight => {\n    if (!fontWeights.includes(selectedWeight)) {\n      (0, next_font_error_1.nextFontError)(`Unknown weight \\`${selectedWeight}\\` for font \\`${fontFamily}\\`.\\nAvailable weights: ${(0, format_available_values_1.formatAvailableValues)(fontWeights)}`);\n    }\n  });\n  if (styles.length === 0) {\n    if (fontStyles.length === 1) {\n      // Handle default style for fonts that only have italic\n      styles.push(fontStyles[0]);\n    } else {\n      // Otherwise set default style to normal\n      styles.push('normal');\n    }\n  }\n  styles.forEach(selectedStyle => {\n    if (!fontStyles.includes(selectedStyle)) {\n      (0, next_font_error_1.nextFontError)(`Unknown style \\`${selectedStyle}\\` for font \\`${fontFamily}\\`.\\nAvailable styles: ${(0, format_available_values_1.formatAvailableValues)(fontStyles)}`);\n    }\n  });\n  if (!constants_1.allowedDisplayValues.includes(display)) {\n    (0, next_font_error_1.nextFontError)(`Invalid display value \\`${display}\\` for font \\`${fontFamily}\\`.\\nAvailable display values: ${(0, format_available_values_1.formatAvailableValues)(constants_1.allowedDisplayValues)}`);\n  }\n  if (weights[0] !== 'variable' && axes) {\n    (0, next_font_error_1.nextFontError)('Axes can only be defined for variable fonts');\n  }\n  return {\n    fontFamily,\n    weights,\n    styles,\n    display,\n    preload,\n    selectedVariableAxes: axes,\n    fallback,\n    adjustFontFallback,\n    variable,\n    subsets\n  };\n}\nexports.validateGoogleFontFunctionCall = validateGoogleFontFunctionCall;","map":{"version":3,"names":["Object","defineProperty","exports","value","validateGoogleFontFunctionCall","constants_1","require","format_available_values_1","next_font_error_1","google_fonts_metadata_1","functionName","fontFunctionArgument","weight","style","preload","display","axes","fallback","adjustFontFallback","variable","subsets","nextFontError","fontFamily","replace","fontFamilyData","googleFontsMetadata","availableSubsets","length","formatAvailableValues","forEach","subset","includes","fontWeights","weights","fontStyles","styles","Set","Array","isArray","push","selectedWeight","selectedStyle","allowedDisplayValues","selectedVariableAxes"],"sources":["/Users/albertformatger/Documents/GitHub/web_musica/node_modules/next/dist/compiled/@next/font/dist/google/validate-google-font-function-call.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateGoogleFontFunctionCall = void 0;\nconst constants_1 = require(\"../constants\");\nconst format_available_values_1 = require(\"../format-available-values\");\nconst next_font_error_1 = require(\"../next-font-error\");\nconst google_fonts_metadata_1 = require(\"./google-fonts-metadata\");\n/**\n * Validate the data recieved from next-swc next-transform-font on next/font/google calls\n */\nfunction validateGoogleFontFunctionCall(functionName, fontFunctionArgument) {\n    let { weight, style, preload = true, display = 'swap', axes, fallback, adjustFontFallback = true, variable, subsets, } = fontFunctionArgument || {};\n    if (functionName === '') {\n        (0, next_font_error_1.nextFontError)(`next/font/google has no default export`);\n    }\n    const fontFamily = functionName.replace(/_/g, ' ');\n    // Get the Google font metadata, we'll use this to validate the font arguments and to print better error messages\n    const fontFamilyData = google_fonts_metadata_1.googleFontsMetadata[fontFamily];\n    if (!fontFamilyData) {\n        (0, next_font_error_1.nextFontError)(`Unknown font \\`${fontFamily}\\``);\n    }\n    const availableSubsets = fontFamilyData.subsets;\n    if (availableSubsets.length === 0) {\n        // If the font doesn't have any preloadeable subsets, disable preload\n        preload = false;\n    }\n    else if (preload) {\n        if (!subsets) {\n            (0, next_font_error_1.nextFontError)(`Preload is enabled but no subsets were specified for font \\`${fontFamily}\\`. Please specify subsets or disable preloading if your intended subset can't be preloaded.\\nAvailable subsets: ${(0, format_available_values_1.formatAvailableValues)(availableSubsets)}\\n\\nRead more: https://nextjs.org/docs/messages/google-fonts-missing-subsets`);\n        }\n        subsets.forEach((subset) => {\n            if (!availableSubsets.includes(subset)) {\n                (0, next_font_error_1.nextFontError)(`Unknown subset \\`${subset}\\` for font \\`${fontFamily}\\`.\\nAvailable subsets: ${(0, format_available_values_1.formatAvailableValues)(availableSubsets)}`);\n            }\n        });\n    }\n    const fontWeights = fontFamilyData.weights;\n    const fontStyles = fontFamilyData.styles;\n    // Get the unique weights and styles from the function call\n    const weights = !weight\n        ? []\n        : [...new Set(Array.isArray(weight) ? weight : [weight])];\n    const styles = !style\n        ? []\n        : [...new Set(Array.isArray(style) ? style : [style])];\n    if (weights.length === 0) {\n        // Set variable as default, throw if not available\n        if (fontWeights.includes('variable')) {\n            weights.push('variable');\n        }\n        else {\n            (0, next_font_error_1.nextFontError)(`Missing weight for font \\`${fontFamily}\\`.\\nAvailable weights: ${(0, format_available_values_1.formatAvailableValues)(fontWeights)}`);\n        }\n    }\n    if (weights.length > 1 && weights.includes('variable')) {\n        (0, next_font_error_1.nextFontError)(`Unexpected \\`variable\\` in weight array for font \\`${fontFamily}\\`. You only need \\`variable\\`, it includes all available weights.`);\n    }\n    weights.forEach((selectedWeight) => {\n        if (!fontWeights.includes(selectedWeight)) {\n            (0, next_font_error_1.nextFontError)(`Unknown weight \\`${selectedWeight}\\` for font \\`${fontFamily}\\`.\\nAvailable weights: ${(0, format_available_values_1.formatAvailableValues)(fontWeights)}`);\n        }\n    });\n    if (styles.length === 0) {\n        if (fontStyles.length === 1) {\n            // Handle default style for fonts that only have italic\n            styles.push(fontStyles[0]);\n        }\n        else {\n            // Otherwise set default style to normal\n            styles.push('normal');\n        }\n    }\n    styles.forEach((selectedStyle) => {\n        if (!fontStyles.includes(selectedStyle)) {\n            (0, next_font_error_1.nextFontError)(`Unknown style \\`${selectedStyle}\\` for font \\`${fontFamily}\\`.\\nAvailable styles: ${(0, format_available_values_1.formatAvailableValues)(fontStyles)}`);\n        }\n    });\n    if (!constants_1.allowedDisplayValues.includes(display)) {\n        (0, next_font_error_1.nextFontError)(`Invalid display value \\`${display}\\` for font \\`${fontFamily}\\`.\\nAvailable display values: ${(0, format_available_values_1.formatAvailableValues)(constants_1.allowedDisplayValues)}`);\n    }\n    if (weights[0] !== 'variable' && axes) {\n        (0, next_font_error_1.nextFontError)('Axes can only be defined for variable fonts');\n    }\n    return {\n        fontFamily,\n        weights,\n        styles,\n        display,\n        preload,\n        selectedVariableAxes: axes,\n        fallback,\n        adjustFontFallback,\n        variable,\n        subsets,\n    };\n}\nexports.validateGoogleFontFunctionCall = validateGoogleFontFunctionCall;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,8BAA8B,GAAG,KAAK,CAAC;AAC/C,MAAMC,WAAW,GAAGC,OAAO,CAAC,cAAc,CAAC;AAC3C,MAAMC,yBAAyB,GAAGD,OAAO,CAAC,4BAA4B,CAAC;AACvE,MAAME,iBAAiB,GAAGF,OAAO,CAAC,oBAAoB,CAAC;AACvD,MAAMG,uBAAuB,GAAGH,OAAO,CAAC,yBAAyB,CAAC;AAClE;AACA;AACA;AACA,SAASF,8BAA8BA,CAACM,YAAY,EAAEC,oBAAoB,EAAE;EACxE,IAAI;IAAEC,MAAM;IAAEC,KAAK;IAAEC,OAAO,GAAG,IAAI;IAAEC,OAAO,GAAG,MAAM;IAAEC,IAAI;IAAEC,QAAQ;IAAEC,kBAAkB,GAAG,IAAI;IAAEC,QAAQ;IAAEC;EAAS,CAAC,GAAGT,oBAAoB,IAAI,CAAC,CAAC;EACnJ,IAAID,YAAY,KAAK,EAAE,EAAE;IACrB,CAAC,CAAC,EAAEF,iBAAiB,CAACa,aAAa,EAAG,wCAAuC,CAAC;EAClF;EACA,MAAMC,UAAU,GAAGZ,YAAY,CAACa,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC;EAClD;EACA,MAAMC,cAAc,GAAGf,uBAAuB,CAACgB,mBAAmB,CAACH,UAAU,CAAC;EAC9E,IAAI,CAACE,cAAc,EAAE;IACjB,CAAC,CAAC,EAAEhB,iBAAiB,CAACa,aAAa,EAAG,kBAAiBC,UAAW,IAAG,CAAC;EAC1E;EACA,MAAMI,gBAAgB,GAAGF,cAAc,CAACJ,OAAO;EAC/C,IAAIM,gBAAgB,CAACC,MAAM,KAAK,CAAC,EAAE;IAC/B;IACAb,OAAO,GAAG,KAAK;EACnB,CAAC,MACI,IAAIA,OAAO,EAAE;IACd,IAAI,CAACM,OAAO,EAAE;MACV,CAAC,CAAC,EAAEZ,iBAAiB,CAACa,aAAa,EAAG,+DAA8DC,UAAW,oHAAmH,CAAC,CAAC,EAAEf,yBAAyB,CAACqB,qBAAqB,EAAEF,gBAAgB,CAAE,8EAA6E,CAAC;IAC3X;IACAN,OAAO,CAACS,OAAO,CAAEC,MAAM,IAAK;MACxB,IAAI,CAACJ,gBAAgB,CAACK,QAAQ,CAACD,MAAM,CAAC,EAAE;QACpC,CAAC,CAAC,EAAEtB,iBAAiB,CAACa,aAAa,EAAG,oBAAmBS,MAAO,iBAAgBR,UAAW,2BAA0B,CAAC,CAAC,EAAEf,yBAAyB,CAACqB,qBAAqB,EAAEF,gBAAgB,CAAE,EAAC,CAAC;MAClM;IACJ,CAAC,CAAC;EACN;EACA,MAAMM,WAAW,GAAGR,cAAc,CAACS,OAAO;EAC1C,MAAMC,UAAU,GAAGV,cAAc,CAACW,MAAM;EACxC;EACA,MAAMF,OAAO,GAAG,CAACrB,MAAM,GACjB,EAAE,GACF,CAAC,GAAG,IAAIwB,GAAG,CAACC,KAAK,CAACC,OAAO,CAAC1B,MAAM,CAAC,GAAGA,MAAM,GAAG,CAACA,MAAM,CAAC,CAAC,CAAC;EAC7D,MAAMuB,MAAM,GAAG,CAACtB,KAAK,GACf,EAAE,GACF,CAAC,GAAG,IAAIuB,GAAG,CAACC,KAAK,CAACC,OAAO,CAACzB,KAAK,CAAC,GAAGA,KAAK,GAAG,CAACA,KAAK,CAAC,CAAC,CAAC;EAC1D,IAAIoB,OAAO,CAACN,MAAM,KAAK,CAAC,EAAE;IACtB;IACA,IAAIK,WAAW,CAACD,QAAQ,CAAC,UAAU,CAAC,EAAE;MAClCE,OAAO,CAACM,IAAI,CAAC,UAAU,CAAC;IAC5B,CAAC,MACI;MACD,CAAC,CAAC,EAAE/B,iBAAiB,CAACa,aAAa,EAAG,6BAA4BC,UAAW,2BAA0B,CAAC,CAAC,EAAEf,yBAAyB,CAACqB,qBAAqB,EAAEI,WAAW,CAAE,EAAC,CAAC;IAC/K;EACJ;EACA,IAAIC,OAAO,CAACN,MAAM,GAAG,CAAC,IAAIM,OAAO,CAACF,QAAQ,CAAC,UAAU,CAAC,EAAE;IACpD,CAAC,CAAC,EAAEvB,iBAAiB,CAACa,aAAa,EAAG,sDAAqDC,UAAW,oEAAmE,CAAC;EAC9K;EACAW,OAAO,CAACJ,OAAO,CAAEW,cAAc,IAAK;IAChC,IAAI,CAACR,WAAW,CAACD,QAAQ,CAACS,cAAc,CAAC,EAAE;MACvC,CAAC,CAAC,EAAEhC,iBAAiB,CAACa,aAAa,EAAG,oBAAmBmB,cAAe,iBAAgBlB,UAAW,2BAA0B,CAAC,CAAC,EAAEf,yBAAyB,CAACqB,qBAAqB,EAAEI,WAAW,CAAE,EAAC,CAAC;IACrM;EACJ,CAAC,CAAC;EACF,IAAIG,MAAM,CAACR,MAAM,KAAK,CAAC,EAAE;IACrB,IAAIO,UAAU,CAACP,MAAM,KAAK,CAAC,EAAE;MACzB;MACAQ,MAAM,CAACI,IAAI,CAACL,UAAU,CAAC,CAAC,CAAC,CAAC;IAC9B,CAAC,MACI;MACD;MACAC,MAAM,CAACI,IAAI,CAAC,QAAQ,CAAC;IACzB;EACJ;EACAJ,MAAM,CAACN,OAAO,CAAEY,aAAa,IAAK;IAC9B,IAAI,CAACP,UAAU,CAACH,QAAQ,CAACU,aAAa,CAAC,EAAE;MACrC,CAAC,CAAC,EAAEjC,iBAAiB,CAACa,aAAa,EAAG,mBAAkBoB,aAAc,iBAAgBnB,UAAW,0BAAyB,CAAC,CAAC,EAAEf,yBAAyB,CAACqB,qBAAqB,EAAEM,UAAU,CAAE,EAAC,CAAC;IACjM;EACJ,CAAC,CAAC;EACF,IAAI,CAAC7B,WAAW,CAACqC,oBAAoB,CAACX,QAAQ,CAAChB,OAAO,CAAC,EAAE;IACrD,CAAC,CAAC,EAAEP,iBAAiB,CAACa,aAAa,EAAG,2BAA0BN,OAAQ,iBAAgBO,UAAW,kCAAiC,CAAC,CAAC,EAAEf,yBAAyB,CAACqB,qBAAqB,EAAEvB,WAAW,CAACqC,oBAAoB,CAAE,EAAC,CAAC;EACjO;EACA,IAAIT,OAAO,CAAC,CAAC,CAAC,KAAK,UAAU,IAAIjB,IAAI,EAAE;IACnC,CAAC,CAAC,EAAER,iBAAiB,CAACa,aAAa,EAAE,6CAA6C,CAAC;EACvF;EACA,OAAO;IACHC,UAAU;IACVW,OAAO;IACPE,MAAM;IACNpB,OAAO;IACPD,OAAO;IACP6B,oBAAoB,EAAE3B,IAAI;IAC1BC,QAAQ;IACRC,kBAAkB;IAClBC,QAAQ;IACRC;EACJ,CAAC;AACL;AACAlB,OAAO,CAACE,8BAA8B,GAAGA,8BAA8B"},"metadata":{},"sourceType":"script","externalDependencies":[]}